<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Nib-Loading HOWTO</title>
    <link rel="stylesheet" type="text/css" href="HOWTO_files/stylesheets/styles.css" />
  </head>

  <body>

    <div class="title">
      <h1>Nib-Loading HOWTO</h1>
    </div>

    <div class="body-text">
      <p>This HOWTO shows how you can load <strong>nibfiles</strong>
        into a running copy of Clozure CL by evaluating Lisp forms. You
        might want to load nibfiles this way to test user-interface
        elements that you are working on for an application project, or
        to enable an application to dynamically load optional
        user-interface elements.</p>

    </div>

    <div class="section-head">
      <h2>Nibfiles</h2>
    </div>

    <div class="body-text">
      <p>A large part of developing Cocoa applications is creating
        user-interface elements using the Cocoa frameworks. Although
        it's perfectly possible to create any user-interface element
        just by making method calls against the frameworks, the more
        standard way to design a user interface is to use Apple's
        InterfaceBuilder application to
        create <strong>nibfiles</strong>&mdash;files of archived
        Objective-C objects that implement the user-interface
        elements.</p>
      
      <p>InterfaceBuilder is an application that ships with Apple's
        Developer Tools. The Developer Tools are an optional install
        that comes with Mac OS X. Before you can use this HOWTO, you'll
        need to make sure that Apple's Developer Tools are installed on
        your system. Members of Apple's developer programs may download
        the tools for free from
        Apple's <href="http://developer.apple.com">developer
          website</href>, but normally there is no need. You can simply
        use the optional Developer Tools installer on the Mac OS X
        system disks to install the tools.</p>
    </div>

    <div class="section-head">
      <h2>Using Nibfiles</h2> 
    </div>

    <div class="body-text">
      <p>Using InterfaceBuilder, you can quickly and easily create
        windows, dialog boxes, text fields, buttons, and other
        user-interface elements. The elements you create with
        InterfaceBuilder have the standard appearance and behavior
        specified by Apple's Human Interface Guidelines.</p>

      <p>InterfaceBuilder saves descriptions of these objects
        in <strong>nibfiles</strong>. These files contain archived
        representations of Objective-C classes and objects. When you
        launch an application and it loads a nibfile, the Cocoa runtime
        creates these Objective-C objects in memory, complete with any
        instance-variable references to other objects that might have
        been saved in the nibfile. In short, a nibfile is an archived
        collection of user-interface objects that Cocoa can quickly and
        easily revive in memory.</p>

      <p>The normal way that Objective-C programmers use nibfiles is
        by storing them in an application bundle. The application's
        Info.plist file (also stored in the bundle) specifies which
        nibfile is the application's main nibfile, and that file is
        loaded automatically when the application starts up. The
        application can dynamically load other nibfiles from the bundle
        by making method calls.</p>

      <p>Lisp applications written with Clozure CL can also use
        nibfiles in this same fashion (see the "currency-converter"
        HOWTO in the "cocoa" examples folder), but Lisp programmers are
        accustomed to highly interactive development, and might want to
        simply load an arbitrary nibfile into a running Clozure CL
        session. Fortunately, this is easy to do.</p>
    </div>

    <div class="section-head">
      <h2>How To Load a Nibfile</h2> 
    </div>

    <div class="body-text">
      <p>Let's start by loading a very simple nibfile from the Clozure
        CL Listener window. Start by launching the Clozure CL
        application.</p>

      <p>In the same directory as this HOWTO file, you'll find a
        nibfile named "hello.nib". This is an extremely simple nibfile
        that creates a single Cocoa window with a greeting in it. We'll
        use forms typed into the Listener window to load it.</p>

      <p>We're going to call the Objective-C class
        method <code>loadNibFile:externalNameTable:withZone:</code> to
        load the nibfile into memory, creating the window that is
        described in the file. First, though, we need to set up some
        data structures that we'll pass to this method.</p>

      <p>The arguments
        to <code>loadNibFile:externalNameTable:withZone:</code> are a
        pathname, a dictionary object, and a memory zone. As with every
        Objective-C method call, we also pass the object that receives
        the message, which in this case is the class NSBundle.</p>

      <p>The pathname is just a reference to the nibfile we want to
        load. The dictionary holds references to objects. In this
        first simple example, we'll use it only to identify the
        nibfile's owner, which in this case is the application
        itself. The zone is a reference to the area of memory where
        the nibfile objects will be allocated.</p>

      <p>Don't worry if none of this makes sense to you; the code to
        create these objects is simple and straightforward, and should
        help clarify what's going on.</p>

      <div class="section-head">
        <h3>1. Get the Zone</h3> 
      </div>

      <p>First, we'll get a memory zone. We'll tell Cocoa to allocate
        the nibfile objects in the same zone that the application
        uses, so getting a zone is a simple matter of asking the
        application for the one it's using.</p>

      <p>Before we can ask the application anything, we need a
        reference to it. We'll ask the class NSApplication to give us a
        reference to the running application.</p>

      <p>Start by changing to the CCL package; most of the utility
        functions we'll use are defined in that package:</p>

      <pre>
        ? (in-package :ccl)
        #&lt;Package "CCL"&gt;
      </pre>

      <p>Next, get a reference to the NSApplication class:</p>

      <pre>
        ? (setf  *my-app*
                 (let* ((class-name (%make-nsstring "NSApplication"))
                        (appclass (#_NSClassFromString class-name)))
                   (#/release class-name)
                   (#/sharedApplication appclass)))
        #&lt;LISP-APPLICATION &lt;LispApplication: 0x1b8de0&gt; (#x1B8DE0)&gt;
      </pre>

      <p>Let's review this form step-by-step.</p>

      <p>First of all, it's going to store the returned application
      object in the variable <code>*my-app*</code>, so that we have it
      convenient for later use.</p>

      <p>We need an <code>NSString</code> object that contains the
      name of the application class, so the code allocates one by
      calling <code>%make-nsstring</code>. The <code>NSString</code>
      object is a dynamically-allocated foreign object, not managed by
      Lisp's garbage-collector, so we'll have to be sure to release it
      later.</p>

      <p>The code next uses the class-name to get the
      actual <code>NSApplication</code> class object, by
      calling <code>#_NSClassFromString</code>.</p>

      <p>Finally, after first releasing the <code>NSString</code>
      object, it calls <code>#/sharedApplication</code> to get the
      running application object, which turns out to be an instance
      of <code>LispApplication</code>.</p>

        <p>Voilà! We have a reference to the running Clozure CL
          application object! Now we can ask it for its zone, where it
          allocates objects in memory:</p>

        <pre>
          ? (setf *my-zone* (#/zone *my-app*))
          #&lt;A Foreign Pointer #x8B000&gt;
        </pre>

        <p>Now we have a reference to the application's zone, which is
          one of the parameters we need to pass
          to <code>loadNibFile:externalNameTable:withZone:</code>.</p>

        <div class="section-head">
          <h3>2. Make a Dictionary</h3> 
        </div>

        <p>The dictionary argument
          to <code>loadNibFile:externalNameTable:withZone:</code> is
          used for two purposes: to identify the nibfile's owner, and
          to collect toplevel objects.</p>

        <p>The nibfile's owner becomes the owner of all the toplevel
          objects created when the nibfile is loaded, objects such as
          windows, buttons, and so on. A nibfile's owner manages the
          objects created when the nibfile is loaded, and provides a
          way for your code to get references to those objects. You
          supply an owner object in the dictionary, under the
          key <code>"NSNibOwner"</code>.</p>

        <p>The toplevel objects are objects, such as windows, that are
          created when the nibfile is loaded. To collect these, you
          can pass an <code>NSMutableArray</code> object under the
          key <code>"NSNibTopLevelObjects"</code>.</p>

        <p>For this first example, we'll pass an owner object (the
          application object), but we don't need to collect toplevel
          objects, so we'll omit
          the <code>"NSNibTopLevelObjects"</code> key.</p>

        <pre>
          ? (setf *my-dict* 
                  (#/dictionaryWithObject:forKey: (@class ns-mutable-dictionary) 
                                                  *my-app* 
                                                  #@"NSNibOwner"))
          #&lt;NS-MUTABLE-DICTIONARY {
                                  NSNibOwner = &lt;LispApplication: 0x1b8e10&gt;;
                                  } (#x137F3DD0)&gt;
            
          </pre>

        <div class="section-head">
          <h3>3. Load the Nibfile</h3> 
        </div>

        <p>Now that we have the zone and the dictionary we need, we
        can load the nibfile. We just need to create an NSString with
        the proper pathname first:</p>

        <pre>
          ? (setf *nib-path* 
                  (%make-nsstring 
                     (namestring "/usr/local/openmcl/ccl/examples/cocoa/nib-loading/hello.nib")))
          #&lt;NS-MUTABLE-STRING "/usr/local/openmcl/ccl/examples/cocoa/nib-loading/hello.nib" (#x13902C10)&gt;
        </pre>

        <p>Now we can actually load the nibfile, passing the method
        the objects we've created:</p>

        <pre>
          ? (#/loadNibFile:externalNameTable:withZone: 
                  (@class ns-bundle)
                  *nib-path*
                  *my-dict*
                  *my-zone*)
          T
        </pre>

        <p>The window defined in the "hello.nib" file should appear
        on the
        screen. The <code>loadNibFile:externalNameTable:withZone:</code>
        method returns <code>T</code> to indicate it loaded the
        nibfile successfully; if it had failed, it would have
        returned <code>NIL</code>.</p>

        </div>

      </body>
    </html>

