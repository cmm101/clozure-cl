OpenMCL 1.1-pre-069826
- There's an (alpha-quality, maybe) port to x86-64 Darwin (e.g., the
  Mac Pro.)  Some known problems include:
  
  * infrequently (but not infrequently enough) the lisp dies on
    startup with a spurious "Trace/BKPT trap" error message.  This
    seems to be timing-dependent and (very generally) seems to
    involve the Mach exception thread not recognizing an exception
    used to effect exception return.  Sometimes, this shows up
    a (:SIGNALED 5) error when REBUILD-CCL runs the lisp to
    create a new image.

  * some math library primitives (#_asin, for one) generate
    spurious incidental FP exceptions that have nothing to
    do with the validity of the arguments or result.  To work around
    this, the lisp ignores FP exceptions which might have occurred
    during a call into the math library; that means that it doesn't
    detect -real- FP exceptions when they're signaled.  (This bug
    only affects things that call into the system math library;
    lisp arithmetic operations that're done inline are not affected.)

  * The version of OSX/Darwin that shipped with the Mac Pro is missing
    some functionality that from OpenMCL's point of view is highly
    desirable (namely, the ability to keep application-level thread-
    specific data in a per-thread block of memory addressed by an
    otherwise unused segment register.)  To get things working (as
    well as they are), the lisp "shares" the segment register that
    the pthreads library uses to access thread data.  This scheme
    isn't intended to be long-lived (and negatively affects
    performance of things like foreign-function calls, callbacks,
    and exception handling).
 
  * The .cdb files (libc only for Tiger) in ccl:darwin-x86-headers64;
    were cross-developed on a Linux x86-64 system, since Apple
    has not yet released the sources to their x86-64 enabled gcc.

- On all platforms, stream code has been rewritten and often offers
  better (sometimes substantially better) performance.  OPEN and
  MAKE-SOCKET have each been extended to take additional keyword
  arguments.

  :SHARING, which can have the values :PRIVATE (the default), :LOCK,
  or :EXTERNAL (NIL is also accepted as synonym for :EXTERNAL)

   :PRIVATE specifies that the stream can only be accessed by
   the thread that created it.  (There was some discussion on openmcl-devel
   about the idea of "transferring ownership" of a stream; this has
   not yet been implemented.)  Attempts to do I/O on a stream with
   :PRIVATE sharing from a thread other than the stream's owner yield
   an error.

   :LOCK specifies that all access to the stream require the calling
   thread to obtain a lock; there are separate "read" and "write"
   locks for IO streams (so it's possible for one thread to read
   from such a stream while another thread writes to it, for instance.)
   :LOCK was the implicit default for all streams prior to this change.
   (See below - under the discussion of the AUTO-FLUSH mechanism -
   for a discussion of one of the implications of this change that
   affects SLIME users.)

   :EXTERNAL (or NIL) specifies that I/O primitives enforce no
   access protocol.  This may be appropriate for some types of application
   which can control stream access via application-level protocols.  Note
   that since even the act of reading from a stream changes its internal
   state (and simultaneous access from multiple threads can therefore
   lead to corruption of that state), some care must be taken in the
   design of such protocols.

  The :BASIC keyword argument influences whether or not the stream
  will be an instance of the class FUNDAMENTAL-STREAM (the superclass
  from which all Gray stream classes inherit) or a subclass of the
  built-in class CCL::BASIC-STREAM.  The default value of :BASIC
  is T and this has effect for FILE-STREAMs created via OPEN;
  SOCKETs are still always implemented as FUNDAMENTAL (Gray) streams,
  though this should change soon.

   The tradeoff between FUNDAMENTAL and BASIC streams is entirely
   between flexibility and (potential or actual) performance.  I/O
   primitives can recognize BASIC-STREAMs and exploit knowledge of
   implementation details; FUNDAMENTAL stream classes can be
   subclassed in a semi-standard way (the Gray streams protocol.)

   For existing stream classes (FILE-STREAMs, SOCKETs, and the
   internal CCL::FD-STREAM classes used to implement file streams
   and sockets), a lot of code can be shared between the
   FUNDAMENTAL and BASIC implementations.  The biggest difference
   should be that that code can be reached from I/O primitives
   like READ-CHAR without going through some steps that're there
   to support generality and extensibility, and skipping those
   steps when that support isn't needed can improve I/O performance.

   Gray stream methods (STREAM-READ-CHAR) should work on
   appropriate BASIC-STREAMs.  (There may still be cases where
   such methods are undefined; such cases should be considered
   bugs.)  It is not guaranteed that Gray stream methods would
   ever be called by I/O primitives to read a character from
   a BASIC-STREAM (though there are still cases where this happens.)

   A simple loop reading 2M characters from a text file runs about
   10X faster when the file is opened the new defaults (:SHARING :PRIVATE
   :BASIC T) than it had before these changes were made.  That sounds
   good, until one realizes that the "equivalent" C loop can be about
   10X faster still ...

 - Forcing output to interactive streams.

   OpenMCL has long had a (mostly undocumented) mechanism whereby
   a mostly idle thread wakes up a few (~3) times per second and
   calls FORCE-OUTPUT on specified OUTPUT-STREAMS; this helps to
   ensure that streams with which a user would be expected to
   interact (the output side of *TERMINAL-IO*, listener windows
   in a GUI, etc.) have all buffered output flushed without
   requiring application or I/O library code to be concerned about
   that.

   The SLIME lisp interaction mode for Emacs uses this mechanism,
   but the changes described above interfere with SLIMEs use of
   it:  in order to be safely accessed from multiple threads (the
   SLIME REPL thread and the thread which does the background
   periodic flushing of buffered output), a stream must have
   been created with :SHARING :LOCK in effect.  This is no longer
   the effective default; the code which does the periodic
   output flushing ignores streams which do not use locks as an
   access/sharing mechanism.  THIS MEANS THAT BUFFERRED OUTPUT
   TO SLIME REPLs WILL NOT BE AUTOMATICALLY FLUSHED TO THE SCREEN.
   A small change to SLIME's "swank-openmcl.lisp" is required
   to restore this functionality.  First,  a brief description of
   a couple of new primitives:

   (CCL:ADD-AUTO-FLUSH-STREAM s)

    Adds "s", which should be a "simple" OUTPUT-STREAM as returned
    by OPEN or MAKE-SOCKET, to a list of streams whose buffered
    output should be periodically flushed.  If S was not created
    with :SHARING :LOCK in effect, the stream will have its
    :SHARING mode changed to put :SHARING :LOCK into effect.

   (CCL:REMOVE-AUTO-FLUSH-STREAM s)
    
    Removes S from the internal list of automatically flushed
    streams.  Does not restore the stream's :SHARING mode, which
    may have been changed by a previous call to ADD-AUTO-FLUSH-STREAM.

 - SLIME changes
   In slime:swank-openmcl.lisp, around line 182, the method

(defmethod make-stream-interactive ((stream ccl:fundamental-output-stream))
  (push stream ccl::*auto-flush-streams*))

   should be changed to use CCL:ADD-AUTOFLUSH-STREAM if it's defined:

(defmethod make-stream-interactive ((stream ccl:fundamental-output-stream))
  (if (fboundp 'ccl::add-auto-flush-stream)
    (ccl::add-auto-flush-stream stream)
    (push stream ccl::*auto-flush-streams*)))

   That's adequate for the moment, since sockets are still 
   FUNDAMENTAL-STREAMs.  When that changes, some more extensive changes
   to swank-openmcl.lisp may become necessary.

- on x86-64, floating-point-underflow exceptions are now enabled
  by default.  (They really should be on ppc as well.)  Again,
  this affects FP operations that are done in lisp code and
  the results of FP operations that are reported in response
  to calls to reasonable (non-Darwin) math libraries.  This
  can affect whether or not some "potential number"  reader 
  tokens are representable as numbers, e.g., whether or not
  attempts to read something like "1.0f-50" signal underflow
  or are quietly mapped to 0.0f0.

- Bug fixes: see ChangeLog



OpenMCL 1.1-pre-060705
- Bug fixes again.  Some internal changes to support a FreeBSD/AMD64
  port that's not quite ready.

- :MCL is back on *features*; there seem to be too many packages out
  there that expect it to be, and there hasn't been enough advance
  notice of its pending removal.
    
OpenMCL 1.1-pre-060623
- Mostly bug fixes (a CLOS bug that prevented the ObjC bridge from 
  working, FIXNUM arrays weren't quite finished on PPC)

- Use Tiger inferfaces (from XCode 10.4u SDK) on DarwinPPC32

- Add gl, gtk2, gnome2 interfaces for x86-64.  Add a tiny
  "gtk2-clock" example, tweak the opengl-ffi (GLUT) example
  so that it works on x86-64.

- Some changes to the ObjC bridge to support loading additional
  frameworks; update the WebKit example to use these new features.

- Still an outstanding issue where things like MAKE-OBJC-INSTANCE
  need access to the interfaces at runtime (and can crash if they
  aren't available.) 

- Build snapshots for LinuxPPC{32,64}.

OpenMCL 1.1-pre-060608
- The FASL version changed, as did the version number which pairs
  the lisp kernel with heap images.  Images saved with older kernels
  can't be loaded on this one; the images/kernels in the 060608
  snapshot tarballs should match.

  Most of the ABI changes that caused these version changes were
  x86-64 specific; some auxiliary stack pointers that had been
  kept in MMX registers are now kept in per-thread memory. (Signal/
  exception handlers generally need to be able to access these
  stack pointers, but at least some versions of the Linux kernel
  don't reliably pass correct values of the MMX registers in the
  signal contexts passed to signal handlers.  Moral: some kinds
  of stack-allocation and foreign-function operations may (or may not)
  be a few cycles slower, but OpenMCL should be a bit less prone
  to fatal segfault exceptions.)

  Other than that, most changes since the 060530 snapshots are
  bugfixes (see the ChangeLog for details).  The x86-64 port has been
  exercised fairly heavily (if somewhat narrowly) and its welcome
  banner now claims that it's a beta release.  I think that that's
  probably fair, and hope that anyone who may have been reluctant to
  test an alpha release will agree and be less reluctant.

- There's still much more to be done, but some preliminary 1.1 documentation
  is now online at:

<http://newsite.openmcl.clozure.com/Doc>

  Note that some relative links on "newsite" may be invalid, but the
  internal links in the Doc directory should work.

  As noted above, it still needs a lot of work; feedback, criticism,
  and help would all be appreciated.

OpenMCL 1.1-pre-060530

- These release notes have gotten woefully out of date.

- OpenMCL now runs on x86-64 (AMD64, Intel EM64T) systems under Linux.
  It announces itself as an alpha release in the Welcome banner; it should
  in fact be very nearly feature-complete (but possibly still buggy.)
  There's a chicken-and-egg issue in that it needs more testing before
  it can be formally released and some people may be waiting for a more
  stable version.

  The build process and most user-visible things should behave the same
  way as on PPC; using REBUILD-CCL (described below) is generally the
  simplest way to rebuild from sources.  A few (intentional) differences:
 
  * the lisp kernel is named "lx86cl64", the default heap image is
    named "LX86CL64" (e.g., the kernel name, case-inverted) and the
    bootstrapping image is conventionally named "x86-boot64".

  * FASL files have the extension "lx64fsl"

  * the kernel build directory is "ccl/lisp-kernel/linuxx8664"

  * the "openmcl64" shell script can be used to invoke the
    lisp, as on 64-bit PPC platforms.

Other changes tend to be a little more modest:

- there is now a specialized FIXNUM array element type on all platforms.
  (distinct from T or (SIGNED-BYTE <machine-word-size>)).  Access to
  such vectors is a little cheaper than the SIGNED-BYTE case (since
  elements are known to be fixnums) and a little easier on the GC
  than the T case (the GC can avoid looking at their contents and
  there are no associated EGC write-barrier issues.)

- "colon" commands entered into the REPL/break loops don't need to
  be parenthesized if the command and all operands are on the same
  line. E.g.

1> :f 0

  and

1> (:f 0)

  are equivalent (and have the effect of examining the raw contents of
  the 0th stack frame)

- the syntax of the :B (backtrace) break-loop has changed; rather
  than taking an optional argument which specifies whether or not
  frame details should be shown, it now accepts keyword arguments
  for specifying:
   
  :start	; unsigned integer: the index of the first frame to show
  :count	; unsigned integer: the maximum number of frames to show
  :detailed-p	; boolean: whether or not to show frame detail

- a new break-loop command :NFRAMES returns the number of stack frames
  accessible to backtrace.  (Both this change and the previous
  are intended to help deal with deep recursion/stack overflow cases.)

- any command-line arguments that follow a "--" pseudo-argument
  are not processed by the lisp startup code and are stored
  (as a list of strings) in CCL:*UNPROCESSED-COMMAND-LINE-ARGUMENTS*.
  E.g.:

shell> openmcl -- -foo 17
[...]
? ccl:*UNPROCESSED-COMMAND-LINE-ARGUMENTS*
=> ("-foo" "17")

OpenMCL 1.1-pre-060226

- The --thread-stack-size (or -Z)  command-line argument changes the values
  of the variables used to determine the sizes of the listener thread.
  The values of these variables will persist accross SAVE-APPLICATION;
  these values have no effect on the sizes of stacks in threads created
  under explicit user control.

- New functions:

  (CCL:GC-VERBOSE on-full-gc &optional (on-egc on-full-gc))

  Causes the GC to print (or stop printing ...) informational messages
  on entry and exit.  The ON-FULL-GC argument controls whether or
  not these messages are printed on ... a full GC, and the ON-EGC
  argument (which defaults to the value of the ON-FULL-GC argument)
  controls whether messages are printed on ephemeral GCs.

  (CCL:GC-VERBOSE-P)

  Returns two values (corresponding to the arguments of the last call
  to CCL:GC-VERBOSE.)

  (CCL:REBUILD-CCL &key :FULL :CLEAN :KERNEL :FORCE :RELOAD :EXIT 
                         :RELOAD-ARGUMENTS)

  Depending on the values of its arguments, recompiles lisp and/or
  kernel sources and optionallly re-generates ("reloads") a heap
  image.

  Arguments:

  clean   deletes FASL and .o files before performing other steps
  kernel  rebuilds the lisp kernel
  force   forces recompilation, even if binary is newer than source
  reload  tries to rebuild a full heap image after other build steps
  exit    quits after all other steps
  full    equivalent to :CLEAN T :KERNEL T :RELOAD T
  reload-arguments a list of strings, passed as additional arguments
                   to the reload step.  E.g. '("--thread-stack-size" "128M").

  Output from the :KERNEL and :RELOAD steps is ordinarily only displayed
  if an error occurs.
  

- Changes

  TRACE now prints an integer (corresponding to the level of indentation)
  on each line of output.

  Tracing callbacks is currently broken (it may be reimplemented; if so,
  it'd be implemented somewhat differently ...)

- Bugs

  Several bugs involving interactions between the GC and (many) active
  threads have been fixed; at least one such bug remains (the symptom
  involves a recently allocated  array somehow getting trashed or GCed
  incorrectly; the  cause has been under investigation for weeks but is 
  still not known.)

OpenMCL 1.1-pre-060125

- FASL version changed; delete old FASL (.dfsl, .pfsl, .dfsl64, .pfsl64) files
 
- "kernel ABI version" changed; build a new lisp kernel before trying to load/use
   060125 images.

-  Changes: (see also ChangeLog)

   New variable:

   CCL:*HOST-PAGE-SIZE*

   Initialized on application startup to contain the MMU/OS page size in bytes.
   This is 4K on PPC platforms (and likely on most? all? x86 platforms).

   New functions:

   CCL:DEFAULT-ALLOCATION-QUANTUM

   Returns an integer, the value of which is used by the lisp kernel when
   mapping heap memory from the OS.  Mapping requests are usually made in
   multiples of this value.  

   This value is read-only; currently, it's 64KB on 32-bit platforms and
   128KB on 64-bit platforms.


   CCL:PROCESS-ALLOCATION-QUANTUM p

   Returns the (per-thread) allocation quantum of the process P.  By default,
   this is the same value as that returned by CCL:DEFAULT-ALLOCATION-QUANTUM,
   but lower values can be specified on a per-process basis (see below.)

   This value is read-only.

   CCL:CURRENT-PROCESS-ALLOCATION-QUANTUM

   Equivalent to (CCL:PROCESS-ALLOCATION-QUANTUM *CURRENT-PROCESS*),
   but can be used with SETF to change the current processes's
   allocation quantum to a value which is between *HOST-PAGE-SIZE* and
   (DEFAULT-ALLOCATION-QUANTUM), inclusive, and which is a power of 2.


   Changes to existing functions:

   Both PROCESS-RUN-FUNCTION and MAKE-PROCESS accept an :ALLOCATION-QUANTUM
   &key argument, which defaults to the value returned by (DEFAULT-ALLOCATION-QUANTUM).
   If provided, the value of the argument should should satisfy the same
   constraints that (SETF (CURRENT-PROCESS-ALLOCATION-QUANTUM) is subject to.

Discussion

In general, larger per-thread allocation quanta are appropriate for programs
where a relatively small number of threads need to allocate memory frequently
and small per-thread quanta are appropriate for larger numbers of threads
that are expected to do small, infrequent memory allocations.

The worst-case scenarios would involve a large number of threads doing
incidental memory allocation with large quanta (that wastes memory and may
trigger the GC too frequently) or a small number of threads doing frequent
memory allocation with small quanta (since such threads could be expected
to fill up their small per-thread memory allocations quickly and frequently
and would waste time frequently allocating more small chunks.)

All of these values interact with the GC and EGC thresholds; the ability
to exercise some control over how much per-threads memory is allocated
at a time can help to ensure that those interactions are appropriate.
When these mechanisms are insufficient, applications should consider the
use of available mechanisms for adjusting GC and EGC thresholds.




OpenMCL 1.1-pre-051027

- A lot of internal changes in the way that special bindings, UNWIND-PROTECT,
  and WITHOUT-INTERRUPTS are implemented (and in how they interact with
  each other.

  One user-visible aspect of this is that UNWIND-PROTECT cleanup forms
  are run with interrupts disabled (the protected form is run with
  interrupts enabled if they were enabled on entry to the UNWIND-PROTECT.)
  This means that something like:

  (unwind-protect
      nil
    (loop))

  will loop uninterruptibly.

- CCL:WITH-INTERRUPTS-ENABLED &body body executes the body with interrupts
  enabled.  The example above could be rewritten as:

  (unwind-protect
      nil
    (with-interrupts-enabled (loop)))

  and the loop would be interruptible.

  These changes introduce binary incompatibility (the FASL version changed,
  as did an internal version number that tries to keep the kernel and
  heap image in synch.)

  Things basically work, but there may be lingering bugs (e.g., as of
  a little while ago, QUIT didn't work because the initial process
  was running with interrupts disabled.)

- PROCESS-TERMINATION-SEMAPHORE
  MAKE-PROCESS and PROCESS-RUN-FUNCTION accept a :TERMINATION-SEMAPHORE
  argument; processes have a PROCESS-TERMINATION-SEMAPHORE accessor
  method.  If the argument is specified and non-null, its value should
  of type SEMAPHORE.

  If a process dies by any means after it's been successfully enabled
  and it has a non-null termination semaphore "at the time of its death", 
  that semaphore will be signaled just before the underlying OS thread
  is destroyed.

  SETF can be used with PROCESS-TERMINATION-SEMAPHORE to change or
  clear a the termination semaphore of a process.  If the target
  process is not the current process when this happens, it's possible
  that the process could die before the SETF takes effect; this
  possibility must be addressed at the application level (i.e., the
  implementation doesn't try to synchronize the calling thread and
  the target in any way.

  A simple example:

  (let* ((s (make-semaphore)))
    (process-run-function `(:name "sleepy" :termination-semaphore ,s)
                           #'(lambda () (sleep 10)))
    (wait-on-semaphore s))

  The calling thread will wait for (roughly) 10 seconds (until the
  "sleepy" thread has had its nap and signals its termination semaphore.)

- A change that was introduced prior to 0.14.3 led to strange, usually
  fatal crashes (usually an unhandled bus error, occasionally a cryptic
  "can't find active area" message and a trip to the kernel debugger)
  under Darwin.  This was caused by an attempt to use certain Mach
  primitives to suspend and resume threads (the way that those
  primitives were used, Mach exception messages were sometimes sent
  twice if the first send was interrupted, and the second send occurred
  after the exception had already been handled (because the first send
  was recieved but not replied to ...)

  1.0 backed out of this change, and used signal handling primitives
  (instead of Mach primitives) to suspend and resume threads.  I -think-
  that I understand the issue with the Mach primitives 
  (#_thread_abort_safely isn't necessary and caused the duplicate
  exception messages to be sent) and have tried to revert to using
  the Mach thread suspension mechanisms.  (If unhandled bus errors -
  that exit to the shell - or cryptic "can't find active area" messages
  reappear, this experiment will be shown to be a failure.)

  There are some obscure but good reasons for favoring the Mach
  primiitves, so it'd be good to know if the problem with using them
  has indeed been identified.

  (The test case involves bad luck and bad timing: two or more
  threads having pending exceptions at the same time and the thread
  whose exception is handled first tries to suspend the others, typically
  on behalf of the GC.  It was possible to run stress tests for many
  hours in 0.14.3 without encountering the bug, and possible to
  encounter it under seemingly light loads.)

- INCF and DECF argument order and fixnum arithmetic.

  Bryan fixed some ANSI test failures related to the order in which INCF
  and DECF evaluate their args.  (One example is:

  (let* ((x 3))
    (incf x (setq x 5)))

  where the correct answer is 10, not 8.)  We both found that fixing
  some cases involving INCF caused some OpenMCL code to compile
  incorrectly and were nervous about introducing these changes fairly
  late in the development cycle, so we backed out of them prior to
  the 1.0 code freeze.

  The reasons for the miscompiled code have to do with how the
  compiler interprets fixnum declarations under typical optimization
  settings.  If A and B are both declared to be FIXNUMS, then
  the expression

  (setq a (+ a b))

  will usually compile to a simple ADD instruction (with no overflow
  checking); if A and B are fixnums, the result will be a fixnum,
  though if an undetected overflow occurred in the addition, the
  result might be missing a significant bit.

  There was code in OpenMCL that assumed that

  (incf a b)

  was exactly the same as

  (setq a (+ a b))

  and in fact that was true under the old (incorrect) definition of
  INCF.  The new definition introduced some temporary bindings:

  (let* ((...)
         (#:temp (+ a b))
         (...))
     (setq a #:temp))

  In this case, the addition was allowed to generate an overflow
  (no type declaration on #:temp), and the SETQ quietly violated
  a type declaration (assigning a non-FIXNUM value to A), leading
  to further problems.

  So far, I found a couple of cases of this in the OpenMCL sources.
  (FWIW, both functions were originally transliterated from C code
  and were trying to mimic C's silent overflow behavior.)

  Moral: if you have code that assumes that INCF or DECF expand
  into simple assignments and are trying to exploit the ways that
  those assignments interact with type declarations, you may
  want to review those assumptions.  If you write code that has
  side effects in the DELTA arguments of INCF or DECF rorms,
  you'll (hopefully) be pleased to see that Bryan's changes 
  allow these side-effects to be handled correctly (at the
  right time.)  If you don't fall into either of these categories,
  you probably won't notice any difference ...

- 64-bit Linux support

  There's a 64-bit LinuxPPC heap image and some rudimentary (libc-only)
  64-bit Linux interfaces in the testing directory.

  (Unlike 64-bit Darwin, 64-bit Linux distributions typically provide
  64-bit versions of "all" standard libraries; I haven't gotten around
  to building 64-bit gnome/gtk/X11/... interfaces yet, but wouldn't
  expect there to be a problem.)

  The 64-bit Linux OpenMCL seems to basically work, but ... OpenMCL
  likes to map its kernel into low addresses (around #x5000); this
  allows compiled lisp code to use conditional branches to "short"
  (16-bit) absolute addresses.  Newer Linux kernels provide a
  "vdso" shared library that's intended to simply communication
  between the OS kernel and userspace libraries and programs; when
  a program is mapped at "non-standard" addresses, the vdso gets
  mapped at address 0.

  I don't fully understand the imlications of this (beyond the fact that
  indirecting through a NULL pointer will access bits and pieces
  of the vdso instead of segfaulting.)  As far as I know, this is
  seen as a minor bug in the Linux kernel, and I -think- that I've
  seen kernel ChangeLog entries that indicate that the problem's been
  fixed in the relatively recent past (and will likely start to
  make it into Linux distributions in the near future.)

  That said - and seeing a library at address 0 certainly makes me a
  little nervous - the LinuxPPC64 port seems to work at least as
  well as the DarwinPPC64 port does (i.e., there may be word-size
  or other bugs lurking around or hiding in plain sight, but it's
  not usually easy to encounter them.)

- As documented (and as hasn't been true in a long time), EOF
  from *STANDARD-INPUT* terminates the REPL when the --batch argument
  is in effect (even if *STANDARD-INPUT* is a tty.)

- QUIT does a FRESH-LINE on and FORCE-OUTPUT to the standard output
  stream (people had reported that output wasn't always flushed
  when --batch or --eval was used; 1.0 was better about this than
  previous versions were, but it still wasn't reliable.)

OpenMCL 1.1-pre-051028
I had been doing development on G5s, and hadn't noticed that the
32-bit lisp had been using a 64-bit instruction.  (I'm a little
confused about how that could have worked; perhaps the 64-bit
instruction gets emulated by the OS, or perhaps my model of
whether 64-bit instructions can be executed in 32-bit mode
is simply incorrect.)

In any case, the 32-bit images produced yesterday don't run on
G4s (or presumably G3s or older systems.)  Ooops.  New images.

OpenMCL 1.1-pre-051029
 A function used by both SET-USER-ENVIRONMENT
and SET-DEVELOPMENT-ENVIRONMENT wasn't properly changing saved bindings
of *PACKAGE*; the last few 1.1-pre releases have come up in the CCL
package, as a result.  Ooops again; new images, again.


OpenMCL 1.1-pre-051204
Not a lot of user-visible changes, but the changes that're there
are a little hard to bootstrap.
Note that new kernel build directories (darwinppc, darwinppc64,
linuxppc, linuxppc64, ...) repace the old versions that don't
have "ppc" in their names.  CVS may not prune the old directories,
especially if they contain files (.o, random junk).
