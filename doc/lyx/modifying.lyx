#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass book
\begin_preamble
% -----------------------------------------  
% Autogenerated LaTeX file from XML DocBook  
% -----------------------------------------  
%%<params>
%%</params>

\usepackage{ifthen}\newboolean{DBKIsBook}
\setboolean{DBKIsBook}{true}
\IfFileExists{ifxetex.sty}{%
    \usepackage{ifxetex}%
  }{%
    \newif\ifxetex
    \xetexfalse
  }
  \ifxetex
\usepackage{fontspec}\usepackage{xltxtra}\setmainfont{DejaVu Serif}
\setsansfont{DejaVu Sans}
\setmonofont{DejaVu Sans Mono}
\else
\fi
\usepackage{fancybox}\usepackage[hyperlink]{docbook}\renewcommand{\DBKreleaseinfo}{}


\title{Modifying Clozure CL}
\author{}

% ------------------
% Collaborators
% ------------------
\renewcommand{\DBKindexation}{
\begin{DBKindtable}
\DBKinditem{\writtenby}{}
\end{DBKindtable}
}
\makeindex
\makeglossary
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding latin1
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref section
\pdf_pdfusetitle true
\pdf_quoted_options "%"
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 5
\tocdepth 5
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Modifying Clozure CL
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Modifying-CCL"

\end_inset








\end_layout

\begin_layout Section
Contributing Code Back to the Clozure CL Project
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Contributing-Code-Back-to-the-CCL-Project"

\end_inset







This section is a placeholder, added as of August 2004.
 The full text is being written, and will be added as soon as it is available.
\end_layout

\begin_layout Section
Using Clozure CL in "development" and in "user" mode
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Using-CCL-in--development--and-in--user--mode"

\end_inset







As it's distributed, Clozure CL starts up with *PACKAGE* set to the CL-

USER package and with most predefined functions and methods protected against
 accidental redefinition.
 The package setting is of course a requirement of ANSI CL, and the protection
 of predefined functions and methods is intended to catch certain types
 of programming errors (accidentally redefining a CL or CCL function) before
 those errors have a chance to do much damage.
\end_layout

\begin_layout Standard
These settings may make using Clozure CL to develop Clozure CL a bit awkward,
 because much of that process assumes you are working in the CCL package
 is current, and a primary purpose of Clozure CL development is to redefine
 some predefined, builtin functions.
 The standard, "routine" ways of building Clozure CL from sources (see )
 -

 COMPILE-

CCL, XCOMPILE-

CCL, and XLOAD-

LEVEL-

0 -

 bind *PACKAGE* to the "CCL" package and enable the redefinition of predefined
 functions; the symbols COMPILE-

CCL, XCOMPILE-

CCL, and XLOAD-

LEVEL-

0 are additionally now exported from the "CCL" package.
\end_layout

\begin_layout Standard
Some other (more ad-

hoc) ways of doing development on Clozure CL—compiling and/or loading individual
 files, incrementally redefining individual functions—may be awkward unless
 one reverts to the mode of operation which was traditionally offered in
 Clozure CL.
 Some Clozure CL source files -

 especially those that comprise the bootstrapping image sources and the
 first few files in the "cold load" sequence -

 are compiled and loaded in the "CCL" package but don't contain (IN-

PACKAGE "CCL") forms, since IN-

PACKAGE doesn't work until later in the cold load sequence.
\end_layout

\begin_layout Standard
The somewhat bizarre behavior of both SET-

USER-

ENVIRONMENT and SET-

DEVELOPMENT-

ENVIRONMENT with respect to the special variables they affect is intended
 to allow those constructs to take effect when the read-

eval-

print loop next returns to a top-

level '? ' prompt; the constructs can meaningfully be used inside LOAD,
 for instance (recall that LOAD binds *PACKAGE*), though using both constructs
 within the same LOAD call would likely be pretty confusing.
\end_layout

\begin_layout Standard
"user" and "development" are otherwise very generic terms; here they're
 intended to enforce the distinction between "using" Clozure CL and "developing"
 it.
\end_layout

\begin_layout Standard
The initial environment from which Clozure CL images are saved is one where
 (SET-

USER-

ENVIRONMENT T) has just been called; in previous versions, it was effectively
 as if (SET-

DEVELOPMENT-

ENVIRONMENT T) had just been called.
\end_layout

\begin_layout Standard
Hopefully, most users of Clozure CL can safely ignore these issues most
 of the time.
 Note that doing (SET-

USER-

ENVIRONMENT T) after loading one's own code (or 3rd-

party code) into Clozure CL would protect that code (as well as Clozure
 CL's) from accidental redefinition; that may be useful in some cases.
\end_layout

\begin_layout Section
The Kernel Debugger
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "kernel-debugger"

\end_inset







In a perfect world, something like this couldn't happen:
\end_layout

\begin_layout Standard

[firstnumber=1,] Welcome to Clozure CL Version x.y! ? (defun foo (x) (declare
 (cons x)) (cdr x)) FOO
\end_layout

\begin_layout Standard
? (foo -1) ;Oops.
 Too late ...
 Unhandled exception 11 at 0x300e90c8, context->regs at #x7ffff6b8 Continue/Debu
gger/eXit <enter>? 


\end_layout

\begin_layout Standard
As you may have noticed, it's not a perfect world; it's rare that the cause
 (attempting to reference the CDR of -

1, and therefore accessing unmapped memory near location 0) of this effect
 (an "Unhandled exception ..." message) is so obvious.
\end_layout

\begin_layout Standard
The addresses printed in the message above aren't very useful unless you're
 debugging the kernel with GDB (and they're often very useful if you are.)
\end_layout

\begin_layout Standard
Aside from causing an exception that the lisp kernel doesn't know how to
 handle, one can also enter the kernel debugger (more) deliberately:
\end_layout

\begin_layout Standard

[firstnumber=1,] ? (defun classify (n) (cond ((> n 0) "Greater") ((< n 0)
 "Less") (t ;; Sheesh ! What else could it be ? (ccl::bug "I give up.
 How could this happen ?")))) CLASSIFY
\end_layout

\begin_layout Standard
? (classify 0) Bug in Clozure CL system code: I give up.
 How could this happen ? ? for help [12345] Clozure CL kernel debugger:
 


\end_layout

\begin_layout Standard
CCL::BUG isn't quite the right tool for this example (a call to BREAK or
 PRINT might do a better job of clearing up the mystery), but it's sometimes
 helpful when those other tools can't be used.
 The lisp error system notices, for instance, if attempts to signal errors
 themselves cause errors to be signaled; this sort of thing can happen if
 CLOS or the I/O system are broken or missing.
 After some small number of recursive errors, the error system gives up
 and calls CCL::BUG.
\end_layout

\begin_layout Standard
If one enters a '?' at the kernel debugger prompt, one will see output like:
\end_layout

\begin_layout Standard

[firstnumber=1,] (S) Find and describe symbol matching specified name (B)
 Show backtrace (X) Exit from this debugger, asserting that any exception
 was handled (K) Kill Clozure CL process (?) Show this help 


\end_layout

\begin_layout Standard
CCL::BUG just does an FF-

CALL into the lisp kernel.
 If the kernel debugger was invoked because of an unhandled exception (such
 as an illegal memory reference) the OS kernel saves the machine state ("context
") in a data structure for us, and in that case some additional options
 can be used to display the contents of the registers at the point of the
 exception.
 Another function—CCL::DBG—causes a special exception to be generated and
 enters the lisp kernel debugger with a non-

null "context":
\end_layout

\begin_layout Standard

[firstnumber=1,] ? (defun classify2 (n) (cond ((> n 0) "Greater") ((< n
 0) "Less") (t (dbg n)))) CLASSIFY2
\end_layout

\begin_layout Standard
? (classify2 0) Lisp Breakpoint While executing: #<Function CLASSIFY2 #x08476cfe
> ? for help [12345] Clozure CL kernel debugger: ? (G) Set specified GPR
 to new value (A) Advance the program counter by one instruction (use with
 caution!) (D) Describe the current exception in greater detail (R) Show
 raw GPR/SPR register values (L) Show Lisp values of tagged registers (F)
 Show FPU registers (S) Find and describe symbol matching specified name
 (B) Show backtrace (X) Exit from this debugger, asserting that any exception
 was handled (P) Propagate the exception to another handler (debugger or
 OS) (K) Kill Clozure CL process (?) Show this help 


\end_layout

\begin_layout Standard
CCL::DBG takes an argument, whose value is copied into the register that
 Clozure CL uses to return a function's primary value (arg_z, which is r23
 on the PowerPC).
 If we were to choose the (L) option at this point, we'd see a dislay like:
\end_layout

\begin_layout Standard

[firstnumber=1,] rnil = 0x01836015 nargs = 0 r16 (fn) = #<Function CLASSIFY2
 #x30379386> r23 (argz) = 0 r22 (argy) = 0 r21 (argx) = 0 r20 (temp0) =
 #<26-element vector subtag = 2F @#x303793ee> r19 (temp1/nextmethodcontext)
 = 6393788 r18 (temp2/nfn) = #<Function CLASSIFY2 #x30379386> r17 (temp3/fname)
 = CLASSIFY2 r31 (save0) = 0 r30 (save1) = *TERMINAL-IO* r29 (save2) = 0
 r28 (save3) = (#<RESTART @#x01867f2e> #<RESTART @#x01867f56>) r27 (save4)
 = () r26 (save5) = () r25 (save6) = () r24 (save7) = () 


\end_layout

\begin_layout Standard
From this we can conclude that the problematic argument to CLASSIFY2 was
 0 (see r23/arg_z), and that I need to work on a better example.
\end_layout

\begin_layout Standard
The R option shows the values of the ALU (and PPC branch unit) registers
 in hex; the F option shows the values of the FPU registers.
\end_layout

\begin_layout Standard
The (B) option shows a raw stack backtrace; it'll try to identify foreign
 functions as well as lisp functions.
 (Foreign function names are guesses based on the nearest preceding exported
 symbol.)
\end_layout

\begin_layout Standard
If you ever unexpectedly find yourself in the "lisp kernel debugger", the
 output of the (L) and (B) options are often the most helpful things to
 include in a bug report.
\end_layout

\begin_layout Section
Using AltiVec in Clozure CL LAP functions
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Using-AltiVec-in-CCL-LAP-functions"

\end_inset








\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Overview--16-"

\end_inset







It's now possible to use AltiVec instructions in PPC LAP (assembler) functions.
\end_layout

\begin_layout Standard
The lisp kernel detects the presence or absence of AltiVec and preserves
 AltiVec state on lisp thread switch and in response to exceptions, but
 the implementation doesn't otherwise use vector operations.
\end_layout

\begin_layout Standard
This document doesn't document PPC LAP programming in general.
 Ideally, there would be some document that did.
\end_layout

\begin_layout Standard
This document does explain AltiVec register-

usage conventions in Clozure CL and explains the use of some lap macros
 that help to enforce those conventions.
\end_layout

\begin_layout Standard
All of the global symbols described below are exported from the CCL package.
 Note that lap macro names, ppc instruction names, and (in most cases) register
 names are treated as strings, so this only applies to functions and global
 variable names.
\end_layout

\begin_layout Standard
Much of the Clozure CL support for AltiVec LAP programming is based on work
 contributed to MCL by Shannon Spires.
\end_layout

\begin_layout Subsection
Register usage conventions
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Register-usage-conventions"

\end_inset







Clozure CL LAP functions that use AltiVec instructions must interoperate
 with each other and with C functions; that fact suggests that they follow
 C AltiVec register usage conventions.
 (vr0-

vr1 scratch, vr2-

vr13 parameters/return value, vr14-

vr19 temporaries, vr20-

vr31 callee-

save non-

volatile registers.)
\end_layout

\begin_layout Standard
The EABI (Embedded Application Binary Interface) used in LinuxPPC doesn't
 ascribe particular significance to the vrsave special-

purpose register; on other platforms (notably MacOS), it's used as a bitmap
 which indicates to system-

level code which vector registers contain meaningful values.
\end_layout

\begin_layout Standard
The WITH-

ALTIVEC-

REGISTERS lap macro generates code that saves, updates, and restores VRSAVE
 on platforms where this is required (as indicated by the value of the special
 variable that controls this behavior) and ignores VRSAVE on platforms that
 don't require it to be maintained.
\end_layout

\begin_layout Standard
On all PPC platforms, it's necessary to save any non-

volatile vector registers (vr20 ..
 vr31) before assigning to them and to restore such registers before returning
 to the caller.
\end_layout

\begin_layout Standard
On platforms that require that VRSAVE be maintained, it's not necessary
 to mention the "use" of vector registers that are used as incoming parameters.
 It's not incorrect to mention their use in a WITH-

ALTIVEC-

REGISTERS form, but it may be unnecessary in many interesting cases.
 One can likewise assume that the caller of any function that returns a
 vector value in vr2 has already set the appropriate bit in VRSAVE to indicate
 that this register is live.
 One could therefore write a leaf function that added the bytes in vr3 and
 vr2 and returned the result in vr2 as:
\end_layout

\begin_layout Standard

[firstnumber=1,] (defppclapfunction vaddubs ((y vr3) (z vr2)) (vaddubs z
 y z) (blr)) 


\end_layout

\begin_layout Standard
When vector registers that aren't incoming parameters are used in a LAP
 function, WITH-

ALTIVEC-

REGISTERS takes care of maintaining VRSAVE and of saving/restoring any non-

volatile vector registers:
\end_layout

\begin_layout Standard

[firstnumber=1,] (defppclapfunction load-array ((n argz)) (check-nargs 1)
 (with-altivec-registers (vr1 vr2 vr3 vr27) ; Clobbers imm0 (li imm0 arch::misc-
data-offset) (lvx vr1 argz imm0) ; load MSQ (lvsl vr27 argz imm0) ; set
 the permute vector (addi imm0 imm0 16) ; address of LSQ (lvx vr2 argz imm0)
 ; load LSQ (vperm vr3 vr1 vr2 vr27) ; aligned result appears in VR3 (dbg
 t)) ; Look at result in some debugger (blr)) 


\end_layout

\begin_layout Standard
AltiVec registers are not preserved by CATCH and UNWIND-

PROTECT.
 Since AltiVec is only accessible from LAP in Clozure CL and since LAP functions
 rarely use high-

level control structures, this should rarely be a problem in practice.
\end_layout

\begin_layout Standard
LAP functions that use non-

volatile vector registers and that call (Lisp ?) code which may use CATCH
 or UNWIND-

PROTECT should save those vector registers before such a call and restore
 them on return.
 This is one of the intended uses of the WITH-

VECTOR-

BUFFER lap macro.
\end_layout

\begin_layout Section
Development-

Mode Dictionary
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Development-Mode-Dictionary"

\end_inset












\end_layout

\begin_layout Subsection
*WARN-

IF-

REDEFINE-

KERNEL*
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "v_warn-if-redefine-kernel"

\end_inset








\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
*warn-

if-

redefine-

kernel
\end_layout

\end_inset

*WARN-

IF-

REDEFINE-

KERNEL* ---
\end_layout

\begin_layout Standard
Variable
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
When true, attempts to redefine (via DEFUN or DEFMETHOD) functions and methods
 that are marked as being "predefined" signal continuable errors.
\end_layout

\begin_layout Standard
Note that these are CERRORs, not warnings, and that no lisp functions or
 methods have been defined in the kernel in MCL or Clozure CL since 1987
 or so.
\end_layout

\begin_layout Standard




\end_layout

\begin_layout Subsection
SET-

DEVELOPMENT-

ENVIRONMENT
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "f_set-development-environment"

\end_inset








\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
set-

development-

environment
\end_layout

\end_inset

SET-

DEVELOPMENT-

ENVIRONMENT ---
\end_layout

\begin_layout Standard
Function
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard

set-development-environment &optional unmark-builtin-functions


\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
Arranges that the outermost special bindings of *PACKAGE* and *WARN-

IF-

REDEFINE-

KERNEL* restore values of the "CCL" package and NIL to these variables,
 respectively.
 If the optional argument is true, marks all globally defined functions
 and methods as being "not predefined" (this is a fairly expensive operation.)
\end_layout

\begin_layout Standard




\end_layout

\begin_layout Subsection
SET-

USER-

ENVIRONMENT
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "f_set-user-environment"

\end_inset








\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
set-

user-

environment
\end_layout

\end_inset

SET-

USER-

ENVIRONMENT ---
\end_layout

\begin_layout Standard
Function
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard

set-user-environment &optional mark-builtin-functions


\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
Arranges that the outermost special bindings of *PACKAGE* and *WARN-

IF-

REDEFINE-

KERNEL* restore values of the "CL-

USER" package and T to these variables, respectively.
 If the optional argument is true, marks all globally defined functions
 and methods as being "predefined" (this is a fairly expensive operation.)
\end_layout

\begin_layout Standard




\end_layout

\begin_layout Subsection
*ALTIVEC-

AVAILABLE*
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "v_altivec-available"

\end_inset








\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
*altivec-

available*
\end_layout

\end_inset

*ALTIVEC-

AVAILABLE* ---
\end_layout

\begin_layout Standard
Variable
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
This variable is initialized each time an Clozure CL session starts based
 on information provided by the lisp kernel.
 Its value is true if AltiVec is present and false otherwise.
 This variable shouldn't be set by user code.
\end_layout

\begin_layout Standard




\end_layout

\begin_layout Subsection
ALTIVEC-

AVAILABLE-

P
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "f_altivec-available-p"

\end_inset








\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
altivec-

available-

p
\end_layout

\end_inset

ALTIVEC-

AVAILABLE-

P ---
\end_layout

\begin_layout Standard
Function
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard

altivec-available-p


\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
Returns non-

NIL if AltiVec is available.
\end_layout

\begin_layout Standard




\end_layout

\begin_layout Subsection
*ALTIVEC-

LAPMACROS-

MAINTAIN-

VRSAVE-

P*
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "v_altivec-lapmacros-maintain-vrsave-p"

\end_inset








\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
*altivec-

lapmacros-

maintain-

vrsave-

p*
\end_layout

\end_inset

*ALTIVEC-

LAPMACROS-

MAINTAIN-

VRSAVE-

P* ---
\end_layout

\begin_layout Standard
Variable
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
Intended to control the expansion of certain lap macros.
 Initialized to NIL on LinuxPPC; initialized to T on platforms (such as
 MacOS X/Darwin) that require that the VRSAVE SPR contain a bitmask of active
 vector registers at all times.
\end_layout

\begin_layout Standard




\end_layout

\begin_layout Subsection
WITH-

ALTIVEC-

REGISTERS
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "lapm_with-altivec-registers"

\end_inset








\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
with-

altivec-

registers
\end_layout

\end_inset

WITH-

ALTIVEC-

REGISTERS ---
\end_layout

\begin_layout Standard
LAP Macro
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard

with-altivec-registers reglist &body body


\end_layout

\begin_layout Subsubsection*
Arguments and Values
\end_layout

\begin_layout Description

reglist

 A list of vector register names (vr0 ..
 vr31).
 
\end_layout

\begin_layout Description

body

 A sequence of PPC LAP instructions.
 
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
\noindent
Specifies the set of AltiVec registers used in body.
 If *altivec-

lapmacros-

maintain-

vrsave-

p* is true when the macro is expanded, generates code to save the VRSAVE
 SPR and updates VRSAVE to include a bitmask generated from the specified
 register list.
 Generates code which saves any non-

volatile vector registers which appear in the register list, executes body,
 and restores the saved non-

volatile vector registers (and, if *altivec-

lapmacros-

maintain-

vrsave-

p* is true, restores VRSAVE as well.
 Uses the IMM0 register (r3) as a temporary.
\end_layout

\begin_layout Standard




\end_layout

\begin_layout Subsection
WITH-

VECTOR-

BUFFER
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "lapm_with-vector-buffer"

\end_inset








\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
with-

vector-

buffer
\end_layout

\end_inset

WITH-

VECTOR-

BUFFER ---
\end_layout

\begin_layout Standard
LAP Macro
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard

with-vector-buffer base n &body body


\end_layout

\begin_layout Subsubsection*
Arguments and Values
\end_layout

\begin_layout Description

base

 Any available general-

purpose register.
 
\end_layout

\begin_layout Description

n

 An integer between 1 and 254, inclusive.
 (Should typically be much, much closer to 1.) Specifies the size of the
 buffer, in 16-

byte units.
 
\end_layout

\begin_layout Description

body

 A sequence of PPC LAP instructions.
 
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
\noindent
Generates code which allocates a 16-

byte aligned buffer large enough to contain N vector registers; the GPR
 base points to the lowest address of this buffer.
 After processing body, the buffer will be deallocated.
 The body should preserve the value of base as long as it needs to reference
 the buffer.
 It's intended that base be used as a base register in stvx and lvx instructions
 within the body.
 
\end_layout

\end_body
\end_document
