#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass book
\begin_preamble
% -----------------------------------------  
% Autogenerated LaTeX file from XML DocBook  
% -----------------------------------------  
%%<params>
%%</params>

\usepackage{ifthen}\newboolean{DBKIsBook}
\setboolean{DBKIsBook}{true}
\IfFileExists{ifxetex.sty}{%
    \usepackage{ifxetex}%
  }{%
    \newif\ifxetex
    \xetexfalse
  }
  \ifxetex
\usepackage{fontspec}\usepackage{xltxtra}\setmainfont{DejaVu Serif}
\setsansfont{DejaVu Sans}
\setmonofont{DejaVu Sans Mono}
\else
\fi
\usepackage{fancybox}\usepackage[hyperlink]{docbook}\renewcommand{\DBKreleaseinfo}{}


\title{The Objective-{}C Bridge}

% ------------------
% Collaborators
% ------------------
\renewcommand{\DBKindexation}{
\begin{DBKindtable}
\DBKinditem{\writtenby}{}
\end{DBKindtable}
}
\makeindex
\makeglossary
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding latin1
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref section
\pdf_pdfusetitle true
\pdf_quoted_options "%"
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 5
\tocdepth 5
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard

\end_layout

\begin_layout Chapter
The Objective-C Bridge
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "The-Objective-C-Bridge"

\end_inset

Mac OS X APIs use a language called Objective-C, which is approximately
 C with some object-oriented extensions modeled on Smalltalk.
 The Objective-C bridge makes it possible to work with Objective-C objects
 and classes from Lisp, and to define classes in Lisp which can be used
 by Objective-C.
\end_layout

\begin_layout Standard
The ultimate purpose of the Objective-C and Cocoa bridges is to make Cocoa
 (the standard user-interface framework on Mac OS X) as easy as possible
 to use from Clozure CL, in order to support the development of GUI applications
 and IDEs on Mac OS X (and on any platform that supports Objective-C, such
 as GNUStep).
 The eventual goal, which is much closer than it used to be, is complete
 integration of Cocoa into CLOS.
\end_layout

\begin_layout Standard
The current release provides Lisp-like syntax and naming conventions for
 the basic Objective-C operations, with automatic type processing and messages
 checked for validity at compile-time.
 It also provides some convenience facilities for working with Cocoa.
\end_layout

\begin_layout Section
Changes in 1.2
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Objective-C-Changes-1.2"

\end_inset

Version 1.2 of Clozure CL exports most of the useful symbols described in
 this chapter; in previous releases, most of them were private in the 
\family typewriter
CCL
\family default
 package.
\end_layout

\begin_layout Standard
There are several new reader macros that make it much more convenient than
 before to refer to several classes of symbols used with the Objective-C
 bridge.
 For a full description of these reader-macros, see the Foreign-Function-Interfa
ce Dictionary, especially the entries at the beginning, describing reader
 macros.
\end_layout

\begin_layout Standard
As in previous releases, 32-bit versions of Clozure CL use 32-bit floats
 and integers in data structures that describe geometry, font sizes and
 metrics, and so on.
 64-bit versions of Clozure CL use 64-bit values where appropriate.
\end_layout

\begin_layout Standard
The Objective-C bridge defines the type 
\family typewriter
NS:CGFLOAT
\family default
 as the Lisp type of the preferred floating-point type on the current platform,
 and defines the constant 
\family typewriter
NS:+CGFLOAT+
\family default
.
 On DarwinPPC32, the foreign types 
\family typewriter
:cgfloat
\family default
, 
\family typewriter
:<NSUI>nteger
\family default
, and 
\family typewriter
:<NSI>nteger
\family default
 are defined by the Objective-C bridge (as 32-bit float, 32-bit unsigned
 integer, and 32-bit signed integer, respectively); these types are defined
 as 64-bit variants in the 64-bit interfaces.
\end_layout

\begin_layout Standard
Every Objective-C class is now properly named, either with a name exported
 from the 
\family typewriter
NS
\family default
 package (in the case of a predefined class declared in the interface files)
 or with the name provided in the 
\family typewriter
DEFCLASS
\family default
 form (with 
\family typewriter
:METACLASS
\family default
 
\family typewriter
NS:+NS-OBJECT
\family default
) which defines the class from Lisp.
 The class's Lisp name is now proclaimed to be a "static" variable (as if
 by 
\family typewriter
DEFSTATIC
\family default
, as described in the "Static Variables" section) and given the class object
 as its value.
 In other words:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(send (find-class 'ns:ns-application) 'shared-application)
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
and
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(send ns:ns-application 'shared-application)
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
are equivalent.
 (Since it's not legal to bind a "static" variable, it may be necessary
 to rename some things so that unrelated variables whose names coincidentally
 conflict with Objective-C class names don't do so.)
\end_layout

\begin_layout Section
Using Objective-C Classes
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Using-Objective-C-Classes"

\end_inset

The class of most standard CLOS classes is named STANDARD-CLASS.
 In the Objective-C object model, each class is an instance of a (usually
 unique) metaclass, which is itself an instance of a "base" metaclass (often
 the metaclass of the class named "NSObject".) So, the Objective-C class
 named "NSWindow" and the Objective-C class "NSArray" are (sole) instances
 of their distinct metaclasses whose names are also "NSWindow" and "NSArray",
 respectively.
 (In the Objective-C world, it's much more common and useful to specialize
 class behavior such as instance allocation.)
\end_layout

\begin_layout Standard
When Clozure CL first loads foreign libraries containing Objective-C classes,
 it identifies the classes they contain.
 The foreign class name, such as "NSWindow", is mapped to an external symbol
 in the "NS" package via the bridge's translation rules, such as NS:NS-WINDOW.
 A similar transformation happens to the metaclass name, with a "+" prepended,
 yielding something like NS:+NS-WINDOW.
\end_layout

\begin_layout Standard
These classes are integrated into CLOS such that the metaclass is an instance
 of the class OBJC:OBJC-METACLASS and the class is an instance of the metaclass.
 SLOT-DESCRIPTION metaobjects are created for each instance variable, and
 the class and metaclass go through something very similar to the "standard"
 CLOS class initialization protocol (with a difference being that these
 classes have already been allocated.)
\end_layout

\begin_layout Standard
Performing all this initialization, which is done when you (require "COCOA"),
 currently takes several seconds; it could conceivably be sped up some,
 but it's never likely to be fast.
\end_layout

\begin_layout Standard
When the process is complete, CLOS is aware of several hundred new Objective-C
 classes and their metaclasses.
 Clozure CL's runtime system can reliably recognize MACPTRs to Objective-C
 classes as being CLASS objects, and can (fairly reliably but heuristically)
 recognize instances of those classes (though there are complicating factors
 here; see below.) SLOT-VALUE can be used to access (and, with care, set)
 instance variables in Objective-C instances.
 To see this, do:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

? (require "COCOA") 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and, after waiting a bit longer for a Cocoa listener window to appear, activate
 that Cocoa listener and do:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

? (describe (ccl::send ccl::*NSApp* 'key-window)) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This sends a message asking for the key window, which is the window that
 has the input focus (often the frontmost), and then describes it.
 As we can see, NS:NS-WINDOWs have lots of interesting slots.
\end_layout

\begin_layout Section
Instantiating Objective-C Objects
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Instantiating-Objective-C-Objects"

\end_inset

Making an instance of an Objective-C class (whether the class in question
 is predefined or defined by the application) involves calling MAKE-INSTANCE
 with the class and a set of initargs as arguments.
 As with STANDARD-CLASS, making an instance involves initializing (with
 INITIALIZE-INSTANCE) an object allocated with ALLOCATE-INSTANCE.
\end_layout

\begin_layout Standard
For example, you can create an ns:ns-number like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

? (make-instance 'ns:ns-number :with-int 42) #<NS-CF-NUMBER 42 (#x85962210)>
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It's worth looking at how this would be done if you were writing in Objective
 C:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[[NSNumber alloc] initWithInt: 42] 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Allocating an instance of an Objective-C class involves sending the class
 an "alloc" message, and then using those initargs that 
\emph on
don't
\emph default
 correspond to slot initargs as the "init" message to be sent to the newly-alloc
ated instance.
 So, the example above could have been done more verbosely as:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

? (defvar *n* (ccl::send (find-class 'ns:ns-number) 'alloc)) 
\end_layout

\begin_layout Plain Layout

*N*
\end_layout

\begin_layout Plain Layout

? (setq *n* (ccl::send *n* :init-with-int 42)) 
\end_layout

\begin_layout Plain Layout

#<NS-CF-NUMBER 42 (#x16D340)> 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That setq is important; this is a case where init decides to replace the
 object and return the new one, instead of modifying the existing one.
 In fact, if you leave out the setq and then try to view the value of *N*,
 Clozure CL will freeze.
 There's little reason to ever do it this way; this is just to show what's
 going on.
\end_layout

\begin_layout Standard
You've seen that an Objective-C initialization method doesn't have to return
 the same object it was passed.
 In fact, it doesn't have to return any object at all; in this case, the
 initialization fails and make-instance returns nil.
\end_layout

\begin_layout Standard
In some special cases, such as loading an ns:ns-window-controller from a
 .nib file, it may be necessary for you to pass the instance itself as one
 of the parameters to the initialization method.
 It goes like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

? (defvar *controller* (make-instance 'ns:ns-window-controller)) 
\end_layout

\begin_layout Plain Layout

*CONTROLLER*
\end_layout

\begin_layout Plain Layout

? (setq *controller* (ccl::send *controller* :init-with-window-nib-name
 #@"DataWindow" 
\end_layout

\begin_layout Plain Layout

                                     :owner *controller*)) 
\end_layout

\begin_layout Plain Layout

#<NS-WINDOW-CONTROLLER <NSWindowController: 0x1fb520> (#x1FB520)> 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This example calls (make-instance) with no initargs.
 When you do this, the object is only allocated, and not initialized.
 It then sends the "init" message to do the initialization by hand.
\end_layout

\begin_layout Standard
There is an alternative API for instantiating Objective-C classes.
 You can call 
\family typewriter
OBJC:MAKE-OBJC-INSTANCE
\family default
, passing it the name of the Objective-C class as a string.
 In previous releases, 
\family typewriter
OBJC:MAKE-OBJC-INSTANCE
\family default
 could be more efficient than 
\family typewriter
OBJC:MAKE-INSTNCE
\family default
 in cases where the class did not define any Lisp slots; this is no longer
 the case.
 You can now regard 
\family typewriter
OBJC:MAKE-OBJC-INSTANCE
\family default
 as completely equivalent to 
\family typewriter
OBJC:MAKE-INSTANCE
\family default
, except that you can pass a string for the classname, which may be convenient
 in the case that the classname is in some way unusual.
\end_layout

\begin_layout Section
Calling Objective-C Methods
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Calling-Objective-C-Methods"

\end_inset

In Objective-C, methods are called "messages", and there's a special syntax
 to send a message to an object:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[w alphaValue] [w setAlphaValue: 0.5] [v mouse: p inRect: r] 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first line sends the method "alphaValue" to the object 
\family typewriter
w
\family default
, with no parameters.
 The second line sends the method "setAlphaValue", with the parameter 0.5.
 The third line sends the method "mouse:inRect:" - yes, all one long word
 - with the parameters 
\family typewriter
p
\family default
 and 
\family typewriter
r
\family default
.
\end_layout

\begin_layout Standard
In Lisp, these same three lines are:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(send w 'alpha-value) (send w :set-alpha-value 0.5) (send v :mouse p :in-rect
 r)
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Notice that when a method has no parameters, its name is an ordinary symbol
 (it doesn't matter what package the symbol is in, as only its name is checked).
 When a method has parameters, each part of its name is a keyword, and the
 keywords alternate with the values.
\end_layout

\begin_layout Standard
These two lines break those rules, and both will result in error messages:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(send w :alpha-value) (send w 'set-alpha-value 0.5) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Instead of (send), you can also invoke (send-super), with the same interface.
 It has roughly the same purpose as CLOS's (call-next-method); when you
 use (send-super), the message is handled by the superclass.
 This can be used to get at the original implementation of a method when
 it is shadowed by a method in your subclass.
\end_layout

\begin_layout Subsection
Type Coercion for Objective-C Method Calls
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Type-Coercion-for-ObjC-Method-Calls"

\end_inset

Clozure CL's FFI handles many common conversions between Lisp and foreign
 data, such as unboxing floating-point args and boxing floating-point results.
 The bridge adds a few more automatic conversions:
\end_layout

\begin_layout Standard
NIL is equivalent to (%NULL-PTR) for any message argument that requires
 a pointer.
\end_layout

\begin_layout Standard
T/NIL are equivalent to #$YES/#$NO for any boolean argument.
\end_layout

\begin_layout Standard
A #$YES/#$NO returned by any method that returns BOOL will be automatically
 converted to T/NIL.
\end_layout

\begin_layout Subsection
Methods which Return Structures
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Methods-which-Return-Structures"

\end_inset

Some Cocoa methods return small structures, such as those used to represent
 points, rects, sizes and ranges.
 When writing in Objective C, the compiler hides the implementation details.
 Unfortunately, in Lisp we must be slightly more aware of them.
\end_layout

\begin_layout Standard
Methods which return structures are called in a special way; the caller
 allocates space for the result, and passes a pointer to it as an extra
 argument to the method.
 This is called a Structure Return, or STRET.
 Don't look at me; I don't name these things.
\end_layout

\begin_layout Standard
Here's a simple use of this in Objective C.
 The first line sends the "bounds" message to v1, which returns a rectangle.
 The second line sends the "setBounds" message to v2, passing that same
 rectangle as a parameter.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

NSRect r = [v1 bounds]; [v2 setBounds r];
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
In Lisp, we must explicitly allocate the memory, which is done most easily
 and safely with 
\begin_inset CommandInset ref
LatexCommand ref
reference "m_rlet"

\end_inset

.
 We do it like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(rlet ((r :<NSR>ect)) (send/stret r v1 'bounds) (send v2 :set-bounds r))
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The rlet allocates the storage (but doesn't initialize it), and makes sure
 that it will be deallocated when we're done.
 It binds the variable r to refer to it.
 The call to 
\family typewriter
send/stret
\family default
 is just like an ordinary call to 
\family typewriter
send
\family default
, except that r is passed as an extra, first parameter.
 The third line, which calls 
\family typewriter
send
\family default
, does not need to do anything special, because there's nothing complicated
 about passing a structure as a parameter.
\end_layout

\begin_layout Standard
In order to make STRETs easier to use, the bridge provides two conveniences.
\end_layout

\begin_layout Standard
First, you can use the macros 
\family typewriter
slet
\family default
 and 
\family typewriter
slet*
\family default
 to allocate and initialize local variables to foreign structures in one
 step.
 The example above could have been written more tersely as:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(slet ((r (send v1 'bounds))) (send v2 :set-bounds r)) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Second, when one call to 
\family typewriter
send
\family default
 is made inside another, the inner one has an implicit 
\family typewriter
slet
\family default
 around it.
 So, one could in fact just write:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(send v1 :set-bounds (send v2 'bounds))
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
There are also several pseudo-functions provided for convenience by the
 Objective-C compiler, to make objects of specific types.
 The following are currently supported by the bridge: NS-MAKE-POINT, NS-MAKE-RAN
GE, NS-MAKE-RECT, and NS-MAKE-SIZE.
\end_layout

\begin_layout Standard
These pseudo-functions can be used within an SLET initform:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(slet ((p (ns-make-point 100.0 200.0))) (send w :set-frame-origin p))
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Or within a call to 
\family typewriter
send
\family default
:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(send w :set-origin (ns-make-point 100.0 200.0)) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, since these aren't real functions, a call like the following won't
 work:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(setq p (ns-make-point 100.0 200.0)) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To extract fields from these objects, there are also some convenience macros:
 NS-MAX-RANGE, NS-MIN-X, NS-MIN-Y, NS-MAX-X, NS-MAX-Y, NS-MID-X, NS-MID-Y,
 NS-HEIGHT, and NS-WIDTH.
\end_layout

\begin_layout Standard
Note that there is also a 
\family typewriter
send-super/stret
\family default
 for use within methods.
 Like 
\family typewriter
send-super
\family default
, it ignores any shadowing methods in a subclass, and calls the version
 of a method which belongs to its superclass.
\end_layout

\begin_layout Subsection
Variable-Arity Messages
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Variable-Arity-Messages"

\end_inset

There are a few messages in Cocoa which take variable numbers of arguments.
 Perhaps the most common examples involve formatted strings:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

[NSString stringWithFormat: @"%f %f" x y] 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Lisp, this would be written:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(send (find-class 'ns:ns-string) :string-with-format #@"%f %f" :double-float
 x :double-float y)
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Note that it's necessary to specify the foreign types of the variables (in
 this example, :double-float), because the compiler has no general way of
 knowing these types.
 (You might think that it could parse the format string, but this would
 only work for format strings which are not determined at runtime.)
\end_layout

\begin_layout Standard
Because the Objective-C runtime system does not provide any information
 on which messages are variable arity, they must be explicitly declared.
 The standard variable arity messages in Cocoa are predeclared by the bridge.
 If you need to declare a new variable arity message, use (DEFINE-VARIABLE-ARITY
-MESSAGE "myVariableArityMessage:").
\end_layout

\begin_layout Subsection
Optimization
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Optimization"

\end_inset

The bridge works fairly hard to optimize message sends, when it has enough
 information to do so.
 There are two cases when it does.
 In either, a message send should be nearly as efficient as when writing
 in Objective C.
\end_layout

\begin_layout Standard
The first case is when both the message and the receiver's class are known
 at compile-time.
 In general, the only way the receiver's class is known is if you declare
 it, which you can do with either a DECLARE or a THE form.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(send (the ns:ns-window w) 'center) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that there is no way in Objective-C to name the class of a class.
 Thus the bridge provides a declaration, @METACLASS.
 The type of an instance of "NSColor" is ns:ns-color.
 The type of the 
\emph on
class
\emph default
 "NSColor" is (@metaclass ns:ns-color):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

 (let ((c (find-class 'ns:ns-color))) (declare ((ccl::@metaclass ns:ns-color)
 c)) (send c 'white-color))
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
The other case that allows optimization is when only the message is known
 at compile-time, but its type signature is unique.
 Of the more-than-6000 messages currently provided by Cocoa, only about
 50 of them have nonunique type signatures.
\end_layout

\begin_layout Standard
An example of a message with a type signature that is not unique is SET.
 It returns VOID for NSColor, but ID for NSSet.
 In order to optimize sends of messages with nonunique type signatures,
 the class of the receiver must be declared at compile-time.
\end_layout

\begin_layout Standard
If the type signature is nonunique or the message is unknown at compile-time,
 then a slower runtime call must be used.
\end_layout

\begin_layout Standard
When the receiver's class is unknown, the bridge's ability to optimize relies
 on a type-signature table which it maintains.
 When first loaded, the bridge initializes this table by scanning every
 method of every Objective-C class.
 When new methods are defined later, the table must be updated.
 This happens automatically when you define methods in Lisp.
 After any other major change, such as loading an external framework, you
 should rebuild the table:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

? (update-type-signatures) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Because 
\family typewriter
send
\family default
 and its relatives 
\family typewriter
send-super
\family default
, 
\family typewriter
send/stret
\family default
, and 
\family typewriter
send-super/stret
\family default
 are macros, they cannot be 
\family typewriter
funcall
\family default
ed, 
\family typewriter
apply
\family default
ed, or passed as arguments to functions.
\end_layout

\begin_layout Standard
To work around this, there are function equivalents to them: 
\family typewriter
%send
\family default
, 
\family typewriter
%send-super
\family default
, 
\family typewriter
%send/stret
\family default
, and 
\family typewriter
%send-super/stret
\family default
.
 However, these functions should be used only when the macros will not do,
 because they are unable to optimize.
\end_layout

\begin_layout Section
Defining Objective-C Classes
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Defining-Objective-C-Classes"

\end_inset

You can define your own foreign classes, which can then be passed to foreign
 functions; the methods which you implement in Lisp will be made available
 to the foreign code as callbacks.
\end_layout

\begin_layout Standard
You can also define subclasses of existing classes, implementing your subclass
 in Lisp even though the parent class was in Objective C.
 One such subclass is CCL::NS-LISP-STRING.
 It is also particularly useful to make subclasses of NS-WINDOW-CONTROLLER.
\end_layout

\begin_layout Standard
We can use the MOP to define new Objective-C classes, but we have to do
 something a little funny: the :METACLASS that we'd want to use in a DEFCLASS
 option generally doesn't exist until we've created the class (recall that
 Objective-C classes have, for the sake of argument, unique and private
 metaclasses.) We can sort of sleaze our way around this by specifying a
 known Objective-C metaclass object name as the value of the DEFCLASS :METACLASS
 object; the metaclass of the root class NS:NS-OBJECT, NS:+NS-OBJECT, makes
 a good choice.
 To make a subclass of NS:NS-WINDOW (that, for simplicity's sake, doesn't
 define any new slots), we could do:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(defclass example-window (ns:ns-window) () (:metaclass ns:+ns-object))
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
That'll create a new Objective-C class named EXAMPLE-WINDOW whose metaclass
 is the class named +EXAMPLE-WINDOW.
 The class will be an object of type OBJC:OBJC-CLASS, and the metaclass
 will be of type OBJC:OBJC-METACLASS.
 EXAMPLE-WINDOW will be a subclass of NS-WINDOW.
\end_layout

\begin_layout Subsection
Defining classes with foreign slots
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Defining-classes-with-foreign-slots"

\end_inset

If a slot specification in an Objective-C class definition contains the
 keyword :FOREIGN-TYPE, the slot will be a "foreign slot" (i.e.
 an Objective-C instance variable).
 Be aware that it is an error to redefine an Objective-C class so that its
 foreign slots change in any way, and Clozure CL doesn't do anything consistent
 when you try to.
\end_layout

\begin_layout Standard
The value of the :FOREIGN-TYPE initarg should be a foreign type specifier.
 For example, if we wanted (for some reason) to define a subclass of NS:NS-WINDO
W that kept track of the number of key events it had received (and needed
 an instance variable to keep that information in), we could say:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(defclass key-event-counting-window (ns:ns-window) ((key-event-count :foreign-ty
pe :int :initform 0 :accessor window-key-event-count)) (:metaclass ns:+ns-object
)) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Foreign slots are always SLOT-BOUNDP, and the initform above is redundant:
 foreign slots are initialized to binary 0.
\end_layout

\begin_layout Subsection
Defining classes with Lisp slots
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Defining-classes-with-Lisp-slots"

\end_inset

A slot specification in an Objective-C class definition that doesn't contain
 the :FOREIGN-TYPE initarg defines a pretty-much normal lisp slot that'll
 happen to be associated with "an instance of a foreign class".
 For instance:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(defclass hemlock-buffer-string (ns:ns-string) ((hemlock-buffer :type hi::hemloc
k-buffer :initform hi:: :accessor string-hemlock-buffer)) (:metaclass ns:+ns-obj
ect))
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
As one might expect, this has memory-management implications: we have to
 maintain an association between a MACPTR and a set of lisp objects (its
 slots) as long as the Objective-C instance exists, and we have to ensure
 that the Objective-C instance exists (does not have its -dealloc method
 called) while lisp is trying to think of it as a first-class object that
 can't be "deallocated" while it's still possible to reference it.
 Associating one or more lisp objects with a foreign instance is something
 that's often very useful; if you were to do this "by hand", you'd have
 to face many of the same memory-management issues.
\end_layout

\begin_layout Section
Defining Objective-C Methods
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Defining-Objective-C-Methods"

\end_inset

In Objective-C, unlike in CLOS, every method belongs to some particular
 class.
 This is probably not a strange concept to you, because C++ and Java do
 the same thing.
 When you use Lisp to define Objective-C methods, it is only possible to
 define methods belonging to Objective-C classes which have been defined
 in Lisp.
\end_layout

\begin_layout Standard
You can use either of two different macros to define methods on Objective-C
 classes.
 
\family typewriter
define-objc-method
\family default
 accepts a two-element list containing a message selector name and a class
 name, and a body.
 
\family typewriter
objc:defmethod
\family default
 superficially resembles the normal CLOS 
\family typewriter
defmethod
\family default
, but creates methods on Objective-C classes with the same restrictions
 as those created by 
\family typewriter
define-objc-method
\family default
.
\end_layout

\begin_layout Subsection
Using 
\family typewriter
define-objc-method
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Using-define-objc-method"

\end_inset

As described in the section Calling Objective-C Methods, the names of Objective-
C methods are broken into pieces, each piece followed by a parameter.
 The types of all parameters must be explicitly declared.
\end_layout

\begin_layout Standard
Consider a few examples, meant to illustrate the use of 
\family typewriter
define-objc-method
\family default
.
 Let us define a class to use in them:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(defclass data-window-controller (ns:ns-window-controller) ((window :foreign-typ
e :id :accessor window) (data :initform nil :accessor data)) (:metaclass
 ns:+ns-object)) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There's nothing special about this class.
 It inherits from 
\family typewriter
ns:ns-window-controller
\family default
.
 It has two slots: 
\family typewriter
window
\family default
 is a foreign slot, stored in the Objective-C world; and 
\family typewriter
data
\family default
 is an ordinary slot, stored in the Lisp world.
\end_layout

\begin_layout Standard
Here is an example of how to define a method which takes no arguments:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(define-objc-method ((:id get-window) data-window-controller) (window self))
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The return type of this method is the foreign type :id, which is used for
 all Objective-C objects.
 The name of the method is 
\family typewriter
get-window
\family default
.
 The body of the method is the single line 
\family typewriter
(window self)
\family default
.
 The variable 
\family typewriter
self
\family default
 is bound, within the body, to the instance that is receiving the message.
 The call to 
\family typewriter
window
\family default
 uses the CLOS accessor to get the value of the window field.
\end_layout

\begin_layout Standard
Here's an example that takes a parameter.
 Notice that the name of the method without a parameter was an ordinary
 symbol, but with a parameter, it's a keyword:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(define-objc-method ((:id :init-with-multiplier (:int multiplier)) data-window-c
ontroller) (setf (data self) (make-array 100)) (dotimes (i 100) (setf (aref
 (data self) i) (* i multiplier))) self)
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
To Objective-C code that uses the class, the name of this method is 
\family typewriter
initWithMultiplier:
\family default
.
 The name of the parameter is 
\family typewriter
multiplier
\family default
, and its type is 
\family typewriter
:int
\family default
.
 The body of the method does some meaningless things.
 Then it returns 
\family typewriter
self
\family default
, because this is an initialization method.
\end_layout

\begin_layout Standard
Here's an example with more than one parameter:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(define-objc-method ((:id :init-with-multiplier (:int multiplier) :and-addend
 (:int addend)) data-window-controller) (setf (data self) (make-array size))
 (dotimes (i 100) (setf (aref (data self) i) (+ (* i multiplier) addend)))
 self) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To Objective-C, the name of this method is 
\family typewriter
initWithMultiplier:andAddend:
\family default
.
 Both parameters are of type 
\family typewriter
:int
\family default
; the first is named 
\family typewriter
multiplier
\family default
, and the second is 
\family typewriter
addend
\family default
.
 Again, the method returns 
\family typewriter
self
\family default
.
\end_layout

\begin_layout Standard
Here is a method that does not return any value, a so-called "void method".
 Where our other methods said 
\family typewriter
:id
\family default
, this one says 
\family typewriter
:void
\family default
 for the return type:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

 (define-objc-method ((:void :take-action (:id sender)) data-window-controller)
 (declare (ignore sender)) (dotimes (i 100) (setf (aref (data self) i) (-
 (aref (data self) i))))) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This method would be called 
\family typewriter
takeAction:
\family default
 in Objective-C.
 The convention for methods that are going to be used as Cocoa actions is
 that they take one parameter, which is the object responsible for triggering
 the action.
 However, this method doesn't actually need to use that parameter, so it
 explicitly ignores it to avoid a compiler warning.
 As promised, the method doesn't return any value.
\end_layout

\begin_layout Standard
There is also an alternate syntax, illustrated here.
 The following two method definitions are equivalent:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(define-objc-method ("applicationShouldTerminate:" "LispApplicationDelegate")
 
\end_layout

\begin_layout Plain Layout

   (:id sender :<BOOL>) 
\end_layout

\begin_layout Plain Layout

  (declare (ignore sender))
\end_layout

\begin_layout Plain Layout

nil) 
\end_layout

\begin_layout Plain Layout

(define-objc-method ((:<BOOL> :application-should-terminate sender) lisp-applica
tion-delegate) 
\end_layout

\begin_layout Plain Layout

   (declare (ignore sender))
\end_layout

\begin_layout Plain Layout

nil) 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Using 
\family typewriter
objc:defmethod
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Using-objc-defmethod"

\end_inset

The macro 
\family typewriter
OBJC:DEFMETHOD
\family default
 can be used to define Objective-C methods.
 It looks superficially like 
\family typewriter
CL:DEFMETHOD
\family default
 in some respects.
\end_layout

\begin_layout Standard
Its syntax is 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(OBC:DEFMETHOD name-and-result-type ((receiver-arg-and-class) &rest other-args)
 &body body) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
name-and-result-type
\family default
 is either an Objective-C message name, for methods that return a value
 of type 
\family typewriter
:ID
\family default
, or a list containing an Objective-C message name and a foreign type specifier
 for methods with a different foreign result type.
\end_layout

\begin_layout Standard

\family typewriter
receiver-arg-and-class
\family default
 is a two-element list whose first element is a variable name and whose
 second element is the Lisp name of an Objective-C class or metaclass.
 The receiver variable name can be any bindable lisp variable name, but
 
\family typewriter
SELF
\family default
 might be a reasonable choice.
 The receiver variable is declared to be "unsettable"; i.e., it is an error
 to try to change the value of the receiver in the body of the method definition.
\end_layout

\begin_layout Standard

\family typewriter
other-args
\family default
 are either variable names (denoting parameters of type 
\family typewriter
:ID
\family default
) or 2-element lists whose first element is a variable name and whose second
 element is a foreign type specifier.
\end_layout

\begin_layout Standard
Consider this example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(objc:defmethod (#/characterAtIndex: :unichar) ((self hemlock-buffer-string)
 (index :<NSUI>nteger)) ...)
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
The method 
\family typewriter
characterAtIndex:
\family default
, when invoked on an object of class 
\family typewriter
HEMLOCK-BUFFER-STRING
\family default
 with an additional argument of type 
\family typewriter
:<NSU>integer
\family default
 returns a value of type 
\family typewriter
:unichar
\family default
.
\end_layout

\begin_layout Standard
Arguments that wind up as some pointer type other than 
\family typewriter
:ID
\family default
 (e.g.
 pointers, records passed by value) are represented as typed foreign pointers,
 so that the higher-level, type-checking accessors can be used on arguments
 of type 
\family typewriter
:ns-rect
\family default
, 
\family typewriter
:ns-point
\family default
, and so on.
\end_layout

\begin_layout Standard
Within the body of methods defined via 
\family typewriter
OBJC:DEFMETHOD
\family default
, the local function 
\family typewriter
CL:CALL-NEXT-METHOD
\family default
 is defined.
 It isn't quite as general as 
\family typewriter
CL:CALL-NEXT-METHOD
\family default
 is when used in a CLOS method, but it has some of the same semantics.
 It accepts as many arguments as are present in the containing method's
 
\family typewriter
other-args
\family default
 list and invokes version of the containing method that would have been
 invoked on instances of the receiver's class's superclass with the receiver
 and other provided arguments.
 (The idiom of passing the current method's arguments to the next method
 is common enough that the 
\family typewriter
CALL-NEXT-METHOD
\family default
 in 
\family typewriter
OBJC:DEFMETHODs
\family default
 should probably do this if it receives no arguments.)
\end_layout

\begin_layout Standard
A method defined via 
\family typewriter
OBJC:DEFMETHOD
\family default
 that returns a structure "by value" can do so by returning a record created
 via 
\family typewriter
MAKE-GCABLE-RECORD
\family default
, by returning the value returned via 
\family typewriter
CALL-NEXT-METHOD
\family default
, or by other similar means.
 Behind the scenes, there may be a pre-allocated instance of the record
 type (used to support native structure-return conventions), and any value
 returned by the method body will be copied to this internal record instance.
 Within the body of a method defined with 
\family typewriter
OBJC:DEFMETHOD
\family default
 that's declared to return a structure type, the local macro 
\family typewriter
OBJC:RETURNING-FOREIGN-STRUCT
\family default
 can be used to access the internal structure.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(objc:defmethod (#/reallyTinyRectangleAtPoint: :ns-rect) 
\end_layout

\begin_layout Plain Layout

     ((self really-tiny-view) (where :ns-point)) 
\end_layout

\begin_layout Plain Layout

  (objc:returning-foreign-struct (r) 
\end_layout

\begin_layout Plain Layout

    (ns:init-ns-rect r (ns:ns-point-x where) (ns:ns-point-y where) single-float-
epsilon single-float-epsilon) r)) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the 
\family typewriter
OBJC:DEFMETHOD
\family default
 creates a new method, then it displays a message to that effect.
 These messages may be helpful in catching errors in the names of method
 definitions.
 In addition, if a 
\family typewriter
OBJC:DEFMETHOD
\family default
 form redefines a method in a way that changes its type signature, Clozure
 CL signals a continuable error.
\end_layout

\begin_layout Subsection
Method Redefinition Constraints
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Method-Redefinition-Constraints"

\end_inset

Objective C was not designed, as Lisp was, with runtime redefinition in
 mind.
 So, there are a few constraints about how and when you can replace the
 definition of an Objective C method.
 Currently, if you break these rules, nothing will collapse, but the behavior
 will be confusing; so don't.
\end_layout

\begin_layout Standard
Objective C methods can be redefined at runtime, but their signatures shouldn't
 change.
 That is, the types of the arguments and the return type have to stay the
 same.
 The reason for this is that changing the signature changes the selector
 which is used to call the method.
\end_layout

\begin_layout Standard
When a method has already been defined in one class, and you define it in
 a subclass, shadowing the original method, they must both have the same
 type signature.
 There is no such constraint, though, if the two classes aren't related
 and the methods just happen to have the same name.
\end_layout

\begin_layout Section
Loading Frameworks
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Loading-Objc-Frameworks"

\end_inset

On Mac OS X, a framework is a structured directory containing one or more
 shared libraries along with metadata such as C and Objective-C header files.
 In some cases, frameworks may also contain additional items such as executables.
\end_layout

\begin_layout Standard
Loading a framework means opening the shared libraries and processing any
 declarations so that Clozure CL can subsequently call its entry points
 and use its data structures.
 Clozure CL provides the function 
\family typewriter
OBJC:LOAD-FRAMEWORK
\family default
 for this purpose.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(OBJC:LOAD-FRAMEWORK framework-name interface-dir) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
framework-name
\family default
 is a string that names the framework (for example, "Foundation", or "Cocoa"),
 and 
\family typewriter
interface-dir
\family default
 is a keyword that names the set of interface databases associated with
 the named framework (for example, 
\family typewriter
:foundation
\family default
, or 
\family typewriter
:cocoa
\family default
).
\end_layout

\begin_layout Standard
Assuming that interface databases for the named frameworks exist on the
 standard search path, 
\family typewriter
OBJC:LOAD-FRAMEWORK
\family default
 finds and initializes the framework bundle by searching OS X's standard
 framework search paths.
 Loading the named framework may create new Objective-C classes and methods,
 add foreign type descriptions and entry points, and adjust Clozure CL's
 dispatch functions.
\end_layout

\begin_layout Standard
If interface databases don't exist for a framework you want to use, you
 will need to create them.
 For more information about creating interface databases, see Creating new
 interface directories.
\end_layout

\begin_layout Section
How Objective-C Names are Mapped to Lisp Symbols
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "How-Objective-C-Names-are-Mapped-to-Lisp-Symbols"

\end_inset

There is a standard set of naming conventions for Cocoa classes, messages,
 etc.
 As long as they are followed, the bridge is fairly good at automatically
 translating between Objective-C and Lisp names.
\end_layout

\begin_layout Standard
For example, "NSOpenGLView" becomes ns:ns-opengl-view; "NSURLHandleClient"
 becomes ns:ns-url-handle-client; and "nextEventMatchingMask:untilDate:inMode:de
queue:" becomes (:next-event-matching-mask :until-date :in-mode :dequeue).
 What a mouthful.
\end_layout

\begin_layout Standard
To see how a given Objective-C or Lisp name will be translated by the bridge,
 you can use the following functions:
\end_layout

\begin_layout Standard
(ccl::objc-to-lisp-classname string) 
\end_layout

\begin_layout Standard
(ccl::lisp-to-objc-classname symbol) 
\end_layout

\begin_layout Standard
(ccl::objc-to-lisp-message string) 
\end_layout

\begin_layout Standard
(ccl::lisp-to-objc-message string) 
\end_layout

\begin_layout Standard
(ccl::objc-to-lisp-init string) 
\end_layout

\begin_layout Standard
(ccl::lisp-to-objc-init keyword-list) 
\end_layout

\begin_layout Standard
Of course, there will always be exceptions to any naming convention.
 Please tell us on the mailing lists if you come across any name translation
 problems that seem to be bugs.
 Otherwise, the bridge provides two ways of dealing with exceptions:
\end_layout

\begin_layout Standard
First, you can pass a string as the class name of MAKE-OBJC-INSTANCE and
 as the message to SEND.
 These strings will be directly interpreted as Objective-C names, with no
 translation.
 This is useful for a one-time exception.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(ccl::make-objc-instance "WiErDclass") 
\end_layout

\begin_layout Plain Layout

(ccl::send o "WiErDmEsSaGe:WithARG:" x y) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alternatively, you can define a special translation rule for your exception.
 This is useful for an exceptional name that you need to use throughout
 your code.
 Some examples:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(ccl::define-classname-translation "WiErDclass" wierd-class) 
\end_layout

\begin_layout Plain Layout

(ccl::define-message-translation "WiErDmEsSaGe:WithARG:" (:weird-message
 :with-arg)) 
\end_layout

\begin_layout Plain Layout

(ccl::define-init-translation "WiErDiNiT:WITHOPTION:" (:weird-init :option
\end_layout

\end_inset

)) 
\end_layout

\begin_layout Standard
The normal rule in Objective-C names is that each word begins with a capital
 letter (except possibly the first).
 Using this rule literally, "NSWindow" would be translated as N-S-WINDOW,
 which seems wrong.
 "NS" is a special word in Objective-C that should not be broken at each
 capital letter.
 Likewise "URL", "PDF", "OpenGL", etc.
 Most common special words used in Cocoa are already defined in the bridge,
 but you can define new ones as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(ccl::define-special-objc-word "QuickDraw")
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Note that message keywords in a SEND such as (SEND V :MOUSE P :IN-RECT R)
 may look like the keyword arguments in a Lisp function call, but they really
 aren't.
 All keywords must be present and the order is significant.
 Neither (:IN-RECT :MOUSE) nor (:MOUSE) translate to "mouse:inRect:"
\end_layout

\begin_layout Standard
Also, as a special exception, an "init" prefix is optional in the initializer
 keywords, so (MAKE-OBJC-INSTANCE 'NS-NUMBER :INIT-WITH-FLOAT 2.7) can also
 be expressed as (MAKE-OBJC-INSTANCE 'NS-NUMBER :WITH-FLOAT 2.7)
\end_layout

\end_body
\end_document
