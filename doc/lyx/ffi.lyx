#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass book
\begin_preamble
% -----------------------------------------  
% Autogenerated LaTeX file from XML DocBook  
% -----------------------------------------  
%%<params>
%%</params>

\usepackage{ifthen}\newboolean{DBKIsBook}
\setboolean{DBKIsBook}{true}
\IfFileExists{ifxetex.sty}{%
    \usepackage{ifxetex}%
  }{%
    \newif\ifxetex
    \xetexfalse
  }
  \ifxetex
\usepackage{fontspec}\usepackage{xltxtra}\setmainfont{DejaVu Serif}
\setsansfont{DejaVu Sans}
\setmonofont{DejaVu Sans Mono}
\else
\fi
\usepackage{fancybox}\usepackage[hyperlink]{docbook}\renewcommand{\DBKreleaseinfo}{}


\title{The Foreign-{}Function Interface}
\author{}

% ------------------
% Collaborators
% ------------------
\renewcommand{\DBKindexation}{
\begin{DBKindtable}
\DBKinditem{\writtenby}{}
\end{DBKindtable}
}
\makeindex
\makeglossary
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding latin1
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref section
\pdf_pdfusetitle true
\pdf_quoted_options "%"
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 5
\tocdepth 5
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
The Foreign-Function Interface
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "The-Foreign-Function-Interface"

\end_inset


\end_layout

\begin_layout Section
Specifying And Using Foreign Types
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Specifying-And-Using-Foreign-Types"

\end_inset


\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Overview-foreign-types"

\end_inset


\family typewriter
CCL
\family default
 provides a fairly rich language for defining and specifying foreign data
 types (this language is derived from CMUCL's "alien type" system.)
\end_layout

\begin_layout Standard
In practice, most foreign type definitions are introduced into 
\family typewriter
CCL
\family default
 via its interface database (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "The-Interface-Database"

\end_inset

), though it's also possible to define foreign types interactively and/or
 programmatically.
\end_layout

\begin_layout Standard

\family typewriter
CCL
\family default
's foreign type system is "evolving" (a polite word for not-quite-complete):
 there are some inconsistencies involving package usage, for instance.
 Symbols used in foreign type specifiers 
\emph on
should
\emph default
 be keywords, but this convention isn't always enforced.
\end_layout

\begin_layout Standard
Foreign type, record, and field names are case-sensitive; 
\family typewriter
CCL
\family default
 uses some escaping conventions (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "Case-sensitivity-of-foreign-names-in-CCL"

\end_inset

) to allow keywords to be used to denote these names.
\end_layout

\begin_layout Subsubsection
Type Annotations
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "type-annotations"

\end_inset

As of version 1.2, 
\family typewriter
CCL
\family default
 supports annotating the types of foreign pointers on Mac OS X.
 Forms that create pointers to foreign memory—that is, 
\family typewriter
MACPTR
\family default
s—store with the 
\family typewriter
MACPTR
\family default
 object a type annotation that identifies the foreign type of the object
 pointed to.
 Calling 
\family typewriter
PRINT-OBJECT
\family default
 on a 
\family typewriter
MACPTR
\family default
 attempts to print information about the identified foreign type, including
 whether it was allocated on the heap or the stack, and whether it's scheduled
 for automatic reclamation by the garbage collector.
\end_layout

\begin_layout Standard
Support for type annotation is not yet complete.
 In particular, some uses of 
\family typewriter
PREF
\family default
 and 
\family typewriter
SLOT-VALUE
\family default
 do ot yet take type annotations into account, and neither do 
\family typewriter
DESCRIBE
\family default
 and 
\family typewriter
INSPECT
\family default
.
\end_layout

\begin_layout Subsubsection
Foreign Types as Classes
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "foreign-type-classes"

\end_inset

Some types of foreign pointers take advantage of the support for type annotation
s, and pointers of these types can be treated as instances of known classes.
 Specifically, a pointer to an 
\family typewriter
:<NSR>ect
\family default
 is recognized as an instance of the built-in class 
\family typewriter
NS:NS-RECT
\family default
, a pointer to an 
\family typewriter
<NSS>ize
\family default
 is treated as an instance of 
\family typewriter
NS:NS-SIZE
\family default
, a pointer to an 
\family typewriter
<NSP>oint
\family default
 is recognized as an instance of 
\family typewriter
NS:NS-POINT
\family default
, and a pointer to an 
\family typewriter
<NSR>ange
\family default
 is recognized as an instance of 
\family typewriter
NS:NS-RANGE
\family default
.
\end_layout

\begin_layout Standard
A few more obscure structure types also support this mechanism, and it's
 possible that a future version will support user definition of similar
 type mappings.
\end_layout

\begin_layout Standard
This support for foreign types as classes provides the following conveniences
 for each supported type: 
\end_layout

\begin_layout Itemize
a 
\family typewriter
PRINT-OBJECT
\family default
 method is defined
\end_layout

\begin_layout Itemize
a foreign type name is created and treated as an alias for the corresponding
 type.
 As an example, the name 
\family typewriter
:NS-RECT
\family default
 is a name for the type that corresponds to 
\family typewriter
NS:NS-RECT
\family default
, and you can use 
\family typewriter
:NS-RECT
\family default
 as a type designator in RLET forms to specify a structure of type 
\family typewriter
NS-RECT
\family default
.
\end_layout

\begin_layout Itemize
the class is integrated into the type system so that 
\family typewriter
(TYPEP R 'NS:NS-RECT)
\family default
 is implemented with fair efficiency.
\end_layout

\begin_layout Itemize
inlined accessor and 
\family typewriter
SETF
\family default
 inverses are defined for the structure type's fields.
 In the case of an 
\family typewriter
<NSR*gt;ect
\family default
, for example, the fields in question are the fields of the embedded point
 and size, so that 
\family typewriter
NS:NS-RECT-X
\family default
, 
\family typewriter
NS:NS-RECT-Y
\family default
, 
\family typewriter
NS:NS-RECT-WIDTH
\family default
, 
\family typewriter
NS-RECT-HEIGHT
\family default
 and 
\family typewriter
SETF
\family default
 inverses are defined.
 The accessors and setter functions typecheck their arguments and the setters
 handle coercion to the appropriate type of 
\family typewriter
CGFLOAT
\family default
 where applicable.
\end_layout

\begin_layout Itemize
an initialization function is defined; for example,
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(NS:INIT-NS-SIZE s w h) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
is roughly equivalent to
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(SETF (NS:NS-SIZE-WIDTH s) w (NS:NS-SIZE-HEIGHT s) h)
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
but might be a little more efficient.
\end_layout

\end_deeper
\begin_layout Itemize
a creation function is defined; for example
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(NS:NS-MAKE-POINT x y)
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
is functionally equivalent to
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(LET ((P (MAKE-GCABLE-RECORD :NS-POINT))) (NS:INIT-NS-POINT P X Y) P) 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
a macro is defined which, like 
\family typewriter
RLET
\family default
, stack-allocates an instance of the foreign record type, optionally initializes
 that instance, and executes a body of code with a variable bound to that
 instance.
\end_layout

\begin_deeper
\begin_layout Standard
For example,
\end_layout

\begin_layout Standard

\bar under
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(NS:WITH-NS-RANGE (R LOC LEN) 
\end_layout

\begin_layout Plain Layout

  (FORMAT T "& RANGE HAS LOCATION S, LENGTH S" (NS:NS-RANGE-LOCATION R)
 (NS:NS-RANGE-LENGTH R))) 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Syntax of Foreign Type Specifiers
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Syntax-of-Foreign-Type-Specifiers"

\end_inset


\end_layout

\begin_layout Itemize
Some foreign types are builtin: keywords denote primitive,builtin types
 such as the IEEE-double-float type (denoted :DOUBLE-FLOAT), in much the
 same way as certain symbols(CONS, FIXNUM,etc.) define primitive CL types.
\end_layout

\begin_layout Itemize
Constructors such as :SIGNED and :UNSIGNED can be used to denote signed
 and unsigned integer subtypes (analogous to the CL type specifiers SIGNED-BYTE
 and UNSIGNED-BYTE.) :SIGNED is shorthand for (:SIGNED 32) and :UNSIGNED
 is shorthand for (:UNSIGNED 32).
\end_layout

\begin_layout Itemize
Aliases for other (perhaps more complicated) types can be defined via CCL:DEF-FO
REIGN-TYPE (sort of like CL:DEFTYPE or the C typedef facility).
 The type :CHAR is defined as an alias for (:SIGNED 8) on some platforms,
 as (:UNSIGNED 8) on others.
\end_layout

\begin_layout Itemize
The construct (:STRUCT 
\emph on
name
\emph default
) can be used to refer to a named structure type; (:UNION 
\emph on
name
\emph default
)can be used to refer to a named union type.
 It isn't necessary to enumerate a structure or union type's fields in order
 to refer to the type.
\end_layout

\begin_layout Itemize
If 
\emph on
X
\emph default
 is a valid foreign type reference,then (:* 
\emph on
X
\emph default
) denotes the foreign type "pointer to
\emph on
 X
\emph default
".
 By convention, (:* T) denotes an anonymous pointer type, vaguely equivalent
 to "void*" in C.
\end_layout

\begin_layout Itemize
If a fieldlist is a list of lists, each of whose CAR is a foreign field
 name (keyword) and whose CADR is a foreign type specifier, then (:STRUCT
 
\emph on
name
\emph default
 ,@fieldlist) is a definition of the structure type 
\emph on
name
\emph default
, and (:UNION
\emph on
 name
\emph default
 ,@fieldlist) is a definition of the union type 
\emph on
name
\emph default
.
 Note that it's necessary to define a structure or union type in order to
 include that type in a structure, union, or array, but only necessary to
 "refer to" a structure or union type in order to define a type alias or
 a pointer type.
\end_layout

\begin_layout Itemize
If 
\emph on
X
\emph default
 is a defined foreign type , then (:array 
\emph on
X
\emph default
 &rest dims) denotes the foreign type "array of 
\emph on
X
\emph default
".
 Although multiple array dimensions are allowed by the :array constructor,
 only single-dimensioned arrays are (at all) well-supported in 
\family typewriter
CCL
\family default
.
\end_layout

\begin_layout Section
Foreign Function Calls
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Foreign-Function-Calls"

\end_inset


\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Overview-foreign-calls"

\end_inset


\family typewriter
CCL
\family default
 provides a number of constructs for calling foreign functions from Lisp
 code (all of them based on the function CCL:%FF-CALL).
 In many cases, 
\family typewriter
CCL
\family default
's interface translator (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "The-Interface-Translator"

\end_inset

) provides information about the foreign function's entrypoint name and
 argument and return types; this enables the use of the #_ reader macro
 (described below), which may be more concise and/or more readable than
 other constructs.
\end_layout

\begin_layout Standard

\family typewriter
CCL
\family default
 also provides a mechanism for defining 
\emph on
callbacks
\emph default
: lisp functions which can be called from foreign code.
\end_layout

\begin_layout Standard
There's no supported way to directly pass lisp data to foreign functions:
 scalar lisp data must be coerced to an equivalent foreign representation,
 and lisp arrays (notably strings) must be copied to non-GCed memory.
\end_layout

\begin_layout Subsubsection
Type Designators for Arguments and Return Values
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Type-Designators-for-Arguments-and-Return-Values"

\end_inset

The types of foreign argument and return values in foreign function calls
 and callbacks can be specified by any of the following keywords:
\end_layout

\begin_layout Description
:UNSIGNED-BYTE The argument/return value is of type (UNSIGNED-BYTE 8) 
\end_layout

\begin_layout Description
:SIGNED-BYTE The argument/return value is of type (SIGNED-BYTE 8) 
\end_layout

\begin_layout Description
:UNSIGNED-HALFWORD The argument/return value is of type (UNSIGNED-BYTE 16)
 
\end_layout

\begin_layout Description
:SIGNED-HALFWORD The argument/return value is of type (SIGNED-BYTE 16) 
\end_layout

\begin_layout Description
:UNSIGNED-FULLWORD The argument/return value is of type (UNSIGNED-BYTE 32)
 
\end_layout

\begin_layout Description
:SIGNED-FULLWORD The argument/return value is of type (SIGNED-BYTE 32) 
\end_layout

\begin_layout Description
:UNSIGNED-DOUBLEWORD The argument/return value is of type (UNSIGNED-BYTE
 64) 
\end_layout

\begin_layout Description
:SIGNED-DOUBLEWORD The argument/return value is of type (SIGNED-BYTE 64)
 
\end_layout

\begin_layout Description
:SINGLE-FLOAT The argument/return value is of type SINGLE-FLOAT 
\end_layout

\begin_layout Description
:DOUBLE-FLOAT The argument/return value is of type DOUBLE-FLOAT 
\end_layout

\begin_layout Description
:ADDRESS The argument/return values is a MACPTR.
 
\end_layout

\begin_layout Description
:VOID or NIL Not valid as an argument type specifier; specifies that there
 is no meaningful return value 
\end_layout

\begin_layout Standard
\noindent
On some platforms, a small positive integer 
\emph on
N
\emph default
 can also be used as an argument specifier; it indicates that the corresponding
 argument is a pointer to an 
\emph on
N
\emph default
-word structure or union which should be passed by value to the foreign
 function.
 Exactly which foreign structures are passed by value and how is very dependent
 on the Application Binary Interface (ABI) of the platform; unless you're
 very familiar with ABI details (some of which are quite baroque), it's
 often easier to let higher-level constructs deal with these details.
\end_layout

\begin_layout Subsubsection
External Entrypoints and Named External Entrypoints
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "External-Entrypoints-and-Named-External-Entrypoints"

\end_inset

PowerPC machine instructions are always aligned on 32-bit boundaries, so
 the two least significant bits of the first instruction ("entrypoint")
 of a foreign function are always 0.
 
\family typewriter
CCL
\family default
 often represents an entrypoint address as a fixnum that's binary-equivalent
 to the entrypoint address: if
\emph on
 E
\emph default
 is an entrypoint address expressed as a signed 32-bit integer, then (ash
 
\emph on
E
\emph default
 -2) is an equivalent fixnum representation of that address.
 An entrypoint address can also be encapsulated in a MACPTR (see FIXTHIS),
 but that's somewhat less efficient.
\end_layout

\begin_layout Standard
Although it's possible to use fixnums or macptrs to represent entrypoint
 addresses, it's somewhat cumbersome to do so.
 
\family typewriter
CCL
\family default
 can cache the addresses of named external functions in structure-like objects
 of type CCL:EXTERNAL-ENTRY-POINT (sometimes abbreviated as EEP).
 Through the use of LOAD-TIME-VALUE, compiled lisp functions are able to
 reference EEPs as constants; the use of an indirection allows 
\family typewriter
CCL
\family default
 runtime system to ensure that the EEP's address is current and correct.
\end_layout

\begin_layout Subsection
Return Conventions for C Structures
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Return-Conventions-for-C-Structures"

\end_inset

On some platforms, C functions that are defined to return structures do
 so by reference: they actually accept a first parameter of type "pointer
 to returned struct/union" - which must be allocated by the caller - and
 don't return a meaningful value.
\end_layout

\begin_layout Standard

\emph on
Exactly
\emph default
 how a C function that's defined to return a foreign structure does so is
 dependent on the ABI (and on the size and composition of the structure/union
 in many cases.)
\end_layout

\begin_layout Section
Referencing and Using Foreign Memory Addresses
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Referencing-and-Using-Foreign-Memory-Addresses"

\end_inset


\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Overview-memory-addresses"

\end_inset


\end_layout

\begin_layout Subsubsection
Basics
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Basics"

\end_inset

For a variety of technical reasons, it isn't generally possible to directly
 reference arbitrary absolute addresses (such as those returned by the C
 library function malloc(), for instance) in 
\family typewriter
CCL
\family default
.
 In 
\family typewriter
CCL
\family default
 (and in MCL), such addresses need to be 
\emph on
encapsulated
\emph default
 in objects of type CCL:MACPTR; one can think of a MACPTR as being a specialized
 type of structure whose sole purpose is to provide a way of referring to
 an underlying "raw" address.
\end_layout

\begin_layout Standard
It's sometimes convenient to blur the distinction between a MACPTR and the
 address it represents; it's sometimes necessary to maintain that distinction.
 It's important to remember that a MACPTR is (generally) a first-class Lisp
 object in the same sense that a CONS cell is: it'll get GCed when it's
 no longer possible to reference it.
 The "lifetime" of a MACPTR doesn't generally have anything to do with the
 lifetime of the block of memory its address points to.
\end_layout

\begin_layout Standard
It might be tempting to ask "How does one obtain the address encapsulated
 by a MACPTR ?".
 The answer to that question is that one doesn't do that (and there's no
 way to do that): addresses aren't first-class objects, and there's no way
 to refer to one.
\end_layout

\begin_layout Standard
Two MACPTRs that encapsulate the same address are EQL to each other.
\end_layout

\begin_layout Standard
There are a small number of ways to directly create a MACPTR (and there's
 a fair amount of syntactic sugar built on top of of those primitives.) These
 primitives will be discussed in greater detail below, but they include:
 
\end_layout

\begin_layout Itemize
Creating a MACPTR with a specified address, usually via the function CCL:%INT-TO
-PTR.
\end_layout

\begin_layout Itemize
Referencing the return value of a foreign function call (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "m_ff-call"

\end_inset

)that's specified to return an address.
\end_layout

\begin_layout Itemize
Referencing a memory location that's specified to contain an address.
\end_layout

\begin_layout Standard
All of these primitive MACPTR-creating operations are usually open-coded
 by the compiler; it has a fairly good notion of what low-level operations
 "produce" MACPTRs and which operations "consume" the addresses that the
 encapsulate, and will usually optimize out the introduction of intermediate
 MACPTRs in a simple expression.
\end_layout

\begin_layout Standard
One consequence of the use of MACPTR objects to encapsulate foreign addresses
 is that (naively) 
\emph on
every reference to a foreign address causes a MACPTR to be allocated.
\end_layout

\begin_layout Standard
Consider a code fragment like the following:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(defun get-next-event ()
\end_layout

\begin_layout Plain Layout

  "get the next event from a hypothetical window system"
\end_layout

\begin_layout Plain Layout

  (loop (let* ((event (#_get_next_window_system_event))) ; via an FF-CALL
 
\end_layout

\begin_layout Plain Layout

          (unless (null-event-p event) (handle-event event))))) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As this is written, each call to the (hypothetical) foreign function #_get_next_
window_system_event will return a new MACPTR object.
 Ignoring for the sake of argument the question of whether this code fragment
 exhibits a good way to poll for external events (it doesn't), it's not
 hard to imagine that this loop could execute several million times per
 second (producing several million MACPTRs per second.) Clearly, the "naive"
 approach is impractical in many cases.
\end_layout

\begin_layout Subsubsection
Stack allocation of—and destructive operations on—MACPTRs.
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Stack-allocation-of---and-destructive-operations-on---MACPTRs-"

\end_inset

If certain conditions held in the environment in which GET-NEXT-EVENT ran—namely
, if it was guaranteed that neither NULL-EVENT-P nor HANDLE-EVENT cached
 or otherwise retained their arguments (the "event" pointer)—there'd be
 a few alternatives to the naive approach.
 One of those approaches would be to use the primitive function %SETF-MACPTR
 (described in greater detail below) to destructively modify a MACPTR (to
 change the value of the address it encapsulates.) The GET-NEXT-EVENT example
 could be re-written as:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(defun get-next-event ()
\end_layout

\begin_layout Plain Layout

  (let* ((event (%int-to-ptr 0))) ; create a MACPTR with address 0
\end_layout

\begin_layout Plain Layout

    (loop
\end_layout

\begin_layout Plain Layout

      (%setf-macptr event (#_get_next_window_system_event)) ; re-use it
\end_layout

\begin_layout Plain Layout

      (unless (null-event-p event)
\end_layout

\begin_layout Plain Layout

        (handle-event event)))))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That version's a bit more realistic: it allocates a single MACPTR outside
 if the loop, then changes its address to point to the current address of
 the hypothetical event structure on each loop iteration.
 If there are a million loop iterations per call to GET-NEXT-EVENT, we're
 allocating a million times fewer MACPTRs per call; that sounds like a Good
 Thing.
\end_layout

\begin_layout Standard
An Even Better Thing would be to advise the compiler that the initial value
 (the null MACPTR) bound to the variable event has dynamic extent (that
 value won't be referenced once control leaves the extent of the binding
 of that variable.) Common Lisp allows us to make such an assertion via a
 DYNAMIC-EXTENT declaration; 
\family typewriter
CCL
\family default
's compiler can recognize the "primitive MACPTR-creating operation" involved
 and can replace it with an equivalent operation that stack-allocates the
 MACPTR object.
 If we're not worried about the cost of allocating that MACPTR on every
 iteration (the cost is small and there's no hidden GC cost), we could move
 the binding back inside the loop:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(defun get-next-event ()
\end_layout

\begin_layout Plain Layout

  (loop
\end_layout

\begin_layout Plain Layout

    (let* ((event (%null-ptr))) ; (%NULL-PTR) is shorthand for (%INT-TO-PTR
 0)
\end_layout

\begin_layout Plain Layout

      (declare (dynamic-extent event))
\end_layout

\begin_layout Plain Layout

      (%setf-macptr event (#_get_next_window_system_event))
\end_layout

\begin_layout Plain Layout

      (unless (null-event-p event)
\end_layout

\begin_layout Plain Layout

        (handle-event event)))))
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
The idiom of binding one or more variables to stack-allocated MACPTRs, then
 destructively modifying those MACPTRs before executing a body of code is
 common enough that 
\family typewriter
CCL
\family default
 provides a macro (WITH-MACPTRS) that handles all of the gory details.
 The following version of GET-NEXT-EVENT is semantically equivalent to the
 previous version, but hopefully a bit more concise:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(defun get-next-event ()
\end_layout

\begin_layout Plain Layout

  (loop
\end_layout

\begin_layout Plain Layout

    (with-macptrs ((event (#_get_next_window_system_event)))
\end_layout

\begin_layout Plain Layout

      (unless (null-event-p event)
\end_layout

\begin_layout Plain Layout

        (handle-event event)))))
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Stack-allocated memory (and stack-allocated pointers to it.)
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Stack-allocated-memory--and-stack-allocated-pointers-to-it--"

\end_inset

Fairly often, the blocks of foreign memory (obtained by malloc or something
 similar) have well-defined lifetimes (they can safely be freed at some
 point when it's known that they're no longer needed and it's known that
 they're no longer referenced.) A common idiom might be:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(with-macptrs (p (#_allocate_foreign_memory size))
\end_layout

\begin_layout Plain Layout

  (unwind-protect
\end_layout

\begin_layout Plain Layout

      (use-foreign-memory p)
\end_layout

\begin_layout Plain Layout

    (#_deallocate_foreign_memory p)))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That's not unreasonable code, but it's fairly expensive for a number of
 reasons: foreign functions calls are themselves fairly expensive (as is
 UNWIND-PROTECT), and most library routines for allocating and deallocating
 foreign memory (things like malloc and free) can be fairly expensive in
 their own right.
\end_layout

\begin_layout Standard
In the idiomatic code above, both the MACPTR P and the block of memory that's
 being allocated and freed have dynamic extent and are therefore good candidates
 for stack allocation.
 
\family typewriter
CCL
\family default
 provides the %STACK-BLOCK macro, which executes a body of code with one
 or more variables bound to stack-allocated MACPTRs which encapsulate the
 addresses of stack-allocated blocks of foreign memory.
 Using %STACK-BLOCK, the idiomatic code is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(%stack-block ((p size))
\end_layout

\begin_layout Plain Layout

  (use-foreign-memory p))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which is a bit more efficient and a bit more concise than the version presented
 earlier.
\end_layout

\begin_layout Standard
%STACK-BLOCK is used as the basis for slightly higher-level things like
 RLET.
 (See 
\begin_inset CommandInset ref
LatexCommand ref
reference "m_rlet"

\end_inset

 for more information about RLET.)
\end_layout

\begin_layout Subsubsection
Caveats
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Caveats-"

\end_inset

Reading from, writing to, allocating, and freeing foreign memory are all
 potentially dangerous operations; this is no less true when these operations
 are performed in 
\family typewriter
CCL
\family default
 than when they're done in C or some other lower-level language.
 In addition, destructive operations on Lisp objects be dangerous, as can
 stack allocation if it's abused (if DYNAMIC-EXTENT declarations are violated.)
 Correct use of the constructs and primitives described here is reliable
 and safe; slightly incorrect use of these constructs and primitives can
 crash 
\family typewriter
CCL
\family default
.
\end_layout

\begin_layout Subsection
Foreign-Memory-Addresses Dictionary
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Foreign-Memory-Addresses-Dictionary"

\end_inset

Unless otherwise noted, all of the symbols mentioned below are exported
 from the CCL package.
\end_layout

\begin_layout Subsubsection
Scalar memory reference
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Scalar-memory-reference"

\end_inset


\end_layout

\begin_layout Description
Syntax 
\end_layout

\begin_layout Description
%get-signed-byte ptr &optional (offset 0)
\end_layout

\begin_layout Description
%get-unsigned-byte ptr &optional (offset 0)
\end_layout

\begin_layout Description
%get-signed-word ptr &optional (offset 0)
\end_layout

\begin_layout Description
%get-unsigned-word ptr &optional (offset 0)
\end_layout

\begin_layout Description
%get-signed-long ptr &optional (offset 0)
\end_layout

\begin_layout Description
%get-unsigned-long ptr &optional (offset 0)
\end_layout

\begin_layout Description
%%get-signed-longlong ptr &optional (offset 0)
\end_layout

\begin_layout Description
%%get-unsigned-longlong ptr &optional (offset 0)
\end_layout

\begin_layout Description
%get-ptr ptr &optional (offset 0)
\end_layout

\begin_layout Description
%get-single-float ptr &optional (offset 0)
\end_layout

\begin_layout Description
%get-double-float ptr &optional (offset 0) 
\end_layout

\begin_layout Description
Description References and returns the signed or unsigned 8-bit byte, signed
 or unsigned 16-bit word, signed or unsigned 32-bit long word, signed or
 unsigned 64-bit long long word, 32-bit address, 32-bit single-float, or
 64-bit double-float at the effective byte address formed by adding offset
 to the address encapsulated by ptr.
 
\end_layout

\begin_layout Description
Arguments
\end_layout

\begin_layout Description
ptr A MACPTR 
\end_layout

\begin_layout Description
offset A fixnum 
\end_layout

\begin_layout Standard
\noindent
All of the memory reference primitives described above can be
\end_layout

\begin_layout Standard
used with SETF.
\end_layout

\begin_layout Subsubsection
%get-bit [Function]
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "iget-bit--Function-"

\end_inset


\end_layout

\begin_layout Description
Syntax %get-bit ptr bit-offset 
\end_layout

\begin_layout Description
Description References and returns the bit-offsetth bit at the address encapsula
ted by ptr.
 (Bit 0 at a given address is the most significant bit of the byte at that
 address.) Can be used with SETF.
 
\end_layout

\begin_layout Description
Arguments 
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Description
ptr A MACPTR 
\end_layout

\begin_layout Description
bit-offset A fixnum 
\end_layout

\begin_layout Subsubsection
%get-bitfield [Function]
\end_layout

\begin_layout Standard
\noindent
\begin_inset CommandInset label
LatexCommand label
name "iget-bitfield--Function-"

\end_inset


\end_layout

\begin_layout Description
Syntax %get-bitfield ptr bit-offset width 
\end_layout

\begin_layout Description
Description References and returns an unsigned integer composed from the
 width bits found bit-offset bits from the address encapsulated by ptr.
 (The least significant bit of the result is the value of (%get-bit ptr
 (1- (+ bit-offset width))).
 Can be used with SETF.
 
\end_layout

\begin_layout Description
Arguments 
\begin_inset space ~
\end_inset

 
\end_layout

\begin_layout Description
ptr A MACPTR
\end_layout

\begin_layout Description
bit-offset A fixnum 
\end_layout

\begin_layout Description
width A positive fixnum 
\end_layout

\begin_layout Subsubsection
%int-to-ptr [Function]
\end_layout

\begin_layout Description
Syntax %int-to-ptr int 
\end_layout

\begin_layout Description
Description Creates and returns a MACPTR whose address matches int.
 
\end_layout

\begin_layout Description
Arguments 
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Description
int An (unsigned-byte <n>) , where <n> is the platform's word size in bits.
\end_layout

\begin_layout Subsubsection
%inc-ptr [Function]
\end_layout

\begin_layout Description
Syntax %inc-ptr ptr &optional (delta 1) 
\end_layout

\begin_layout Description
Description Creates and returns a MACPTR whose address is the address of
 ptr plus delta.
 The idiom (%inc-ptr ptr 0) is sometimes used to copy a MACPTR, e.g., to create
 a new MACPTR encapsulating the same address as ptr.
 
\end_layout

\begin_layout Description
Arguments 
\begin_inset space ~
\end_inset


\end_layout

\begin_deeper
\begin_layout Description
ptr A MACPTR 
\end_layout

\begin_layout Description
delta A fixnum 
\end_layout

\end_deeper
\begin_layout Subsubsection
%ptr-to-int [Function]
\end_layout

\begin_layout Description
Syntax %ptr-to-int ptr 
\end_layout

\begin_layout Description
Description Returns the address encapsulated by ptr, as an (unsigned-byte
 <n>) where <n> is the platform's word size in bits.
 
\end_layout

\begin_layout Description
Arguments 
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Description
ptr A MACPTR 
\end_layout

\begin_layout Subsubsection
%null-ptr [Macro]
\end_layout

\begin_layout Description
Syntax %null-ptr 
\end_layout

\begin_layout Description
Description Equivalent to (%int-to-ptr 0).
 
\end_layout

\begin_layout Subsubsection
%null-ptr-p [Function]
\end_layout

\begin_layout Description
Syntax %null-ptr-p ptr 
\end_layout

\begin_layout Description
Description Returns T If ptr is a MACPTR encapsulating the address 0, NIL
 if ptr encapsulates some other address.
 
\end_layout

\begin_layout Description
Arguments 
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Description
ptr A MACPTR 
\end_layout

\begin_layout Subsubsection
%setf-macptr [Function]
\end_layout

\begin_layout Description
Syntax %setf-macptr dest-ptr src-ptr 
\end_layout

\begin_layout Description
Description Causes dest-ptr to encapsulate the same address that src-ptr
 does, then returns dest-ptr.
 
\end_layout

\begin_layout Description
Arguments 
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Description
dest-ptr A MACPTR 
\end_layout

\begin_layout Description
src-ptr A MACPTR 
\end_layout

\begin_layout Subsubsection
%incf-ptr [Macro]
\end_layout

\begin_layout Description
Syntax %incf-ptr ptr &optional (delta 1) 
\end_layout

\begin_layout Description
Description Destructively modifies ptr, by adding delta to the address it
 encapsulates.
 Returns ptr.
 
\end_layout

\begin_layout Description
Arguments 
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Description
ptr A MACPTR 
\end_layout

\begin_layout Description
delta A fixnum 
\end_layout

\begin_layout Subsubsection
with-macptrs [Macro]
\end_layout

\begin_layout Description
Syntax with-macptrs (var expr)* &body body 
\end_layout

\begin_layout Description
Description Executes body in an environment in which each var is bound to
 a stack-allocated macptr which encapsulates the foreign address yielded
 by the corresponding expr.
 Returns whatever value(s) body returns.
 
\end_layout

\begin_layout Description
Arguments 
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Description
var A symbol (variable name) 
\end_layout

\begin_layout Description
expr A MACPTR-valued expression 
\end_layout

\begin_layout Subsubsection
%stack-block [Macro]
\end_layout

\begin_layout Description
Syntax %stack-block (var expr)* &body body 
\end_layout

\begin_layout Description
Description Executes body in an environment in which each var is bound to
 a stack-allocated macptr which encapsulates the address of a stack-allocated
 region of size expr bytes.
 Returns whatever value(s) body returns.
 
\end_layout

\begin_layout Description
Arguments 
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Description
var A symbol (variable name) 
\end_layout

\begin_layout Description
expr An expression which should evaluate to a non-negative fixnum 
\end_layout

\begin_layout Subsubsection
make-cstring [Function]
\end_layout

\begin_layout Description
Syntax make-cstring string 
\end_layout

\begin_layout Description
Description Allocates a block of memory (via malloc) of length (1+ (length
 string)).
 Copies the string to this block and appends a trailing NUL byte; returns
 a MACPTR to the block.
 
\end_layout

\begin_layout Description
Arguments 
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Description
string A lisp string 
\end_layout

\begin_layout Subsubsection
with-cstrs [Macro]
\end_layout

\begin_layout Description
Syntax with-cstrs (var string)* &body body 
\end_layout

\begin_layout Description
Description Executes body in an environment in which each var is bound to
 a stack-allocated macptr which encapsulates the %address of a stack-allocated
 region of into which each string (and a trailing NUL byte) has been copied.
 Returns whatever value(s) body returns.
 
\end_layout

\begin_layout Description
Arguments 
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Description
var A symbol (variable name) 
\end_layout

\begin_layout Description
string An expression which should evaluate to a lisp string 
\end_layout

\begin_layout Subsubsection
with-encoded-cstrs [Macro]
\end_layout

\begin_layout Description
Syntax with-encoded-cstrs ENCODING-NAME (varI stringI)* &body body 
\end_layout

\begin_layout Description
Description Executes body in an environment in which each varI is bound
 to a macptr which encapsulates the %address of a stack-allocated region
 of into which each stringI (and a trailing NUL character) has been copied.
 Returns whatever value(s) body returns.
\end_layout

\begin_layout Standard
ENCODING-NAME is a keyword constant that names a character encoding.
 Each foreign string is encoded in the named encoding.
 Each foreign string has dynamic extent.
\end_layout

\begin_layout Standard
WITH-ENCODED-CSTRS does not automatically prepend byte-order marks to its
 output; the size of the terminating #
\backslash
NUL character depends on the number of octets per code unit in the encoding.
\end_layout

\begin_layout Standard
The expression
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(ccl:with-cstrs ((x "x")) (#_puts x))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
is functionally equivalent to
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(ccl:with-encoded-cstrs :iso-8859-1 ((x "x")) (#_puts x))
\end_layout

\end_inset


\end_layout

\begin_layout Description
Arguments 
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Description
varI A symbol (variable name) 
\end_layout

\begin_layout Description
stringI An expression which should evaluate to a lisp string 
\end_layout

\begin_layout Subsubsection
%get-cstring [Function]
\end_layout

\begin_layout Description
Syntax %get-cstring ptr 
\end_layout

\begin_layout Description
Description Interprets ptr as a pointer to a (NUL -terminated) C string;
 returns an equivalent lisp string.
 
\end_layout

\begin_layout Description
Arguments 
\end_layout

\begin_layout Description
ptr A MACPTR 
\end_layout

\begin_layout Subsubsection
%str-from-ptr [Function]
\end_layout

\begin_layout Description
Syntax %str-from-ptr ptr length 
\end_layout

\begin_layout Description
Description Returns a lisp string of length 
\family typewriter
length
\family default
, whose contents are initialized from the bytes at
\family typewriter
 ptr.

\family default
 
\end_layout

\begin_layout Description
Arguments 
\end_layout

\begin_layout Description
ptr A MACPTR 
\end_layout

\begin_layout Description
length a non-negative fixnum 
\end_layout

\begin_layout Section
The Interface Database
\end_layout

\begin_layout Standard
\noindent
\begin_inset CommandInset label
LatexCommand label
name "The-Interface-Database"

\end_inset


\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "interface-database-Overview"

\end_inset


\family typewriter
CCL
\family default
 uses a set of database files which contain foreign type, record, constant,
 and function definitions derived from the operating system's header files.
 An archive containing these database files (and the shell scripts which
 were used in their creation) is available; see the Distributions page for
 information about obtaining current interface database files.
\end_layout

\begin_layout Standard
Not surprisingly, different platforms use different database files.
\end_layout

\begin_layout Standard

\family typewriter
CCL
\family default
 defines reader macros that consult these databases: 
\end_layout

\begin_layout Itemize
#$foo looks up the value of the constant definition of foo
\end_layout

\begin_layout Itemize
#_foo looks up the foreign function definition for foo
\end_layout

\begin_layout Standard
In both cases, the symbol foo is interned in the "OS" package.
 The #$ reader macro has the side-effect of defining foo as a constant (as
 if via DEFCONSTANT); the #_ reader macro has the side effect of defining
 foo as a macro which will expand into an (EXTERNAL-CALL form.)
\end_layout

\begin_layout Standard
It's important to remember that the side-effect happens when the form containing
 the reader macro is read.
 Macroexpansion functions that expand into forms which contain instances
 of those reader macros don't do what one might think that they do, unless
 the macros are expanded in the same lisp session as the reader macro was
 read in.
\end_layout

\begin_layout Standard
In addition, references to foreign type, structure/union, and field names
 (when used in the RREF/PREF and RLET macros) will cause these database
 files to be consulted.
\end_layout

\begin_layout Standard
Since the 
\family typewriter
CCL
\family default
 sources contain instances of these reader macros (and references to foreign
 record types and fields), compiling 
\family typewriter
CCL
\family default
 from those sources depends on the ability to find and use (see [?]).
\end_layout

\begin_layout Subsection
Other issues:
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Other-issues"

\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
CCL
\family default
 now preserves the case of external symbols in its database files.
 See 
\begin_inset CommandInset ref
LatexCommand ref
reference "Case-sensitivity-of-foreign-names-in-CCL"

\end_inset

 for information about case in foreign symbol names.
\end_layout

\begin_layout Itemize
The Linux databases are derived from a somewhat arbitrary set of Linux header
 files.
 Linux is enough of a moving target that it may be difficult to define a
 standard, reference set of interfaces from which to derive a standard,
 reference set of database files.This seems to be less of an issue with Darwin
 and FreeBSD.
\end_layout

\begin_layout Standard
For information about building the database files, see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "The-Interface-Translator"

\end_inset

.
\end_layout

\begin_layout Section
Using Interface Directories
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Using-Interface-Directories"

\end_inset


\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Interface-Directory-Overview"

\end_inset

As distributed, the "ccl:headers;" (for LinuxPPC) directory is organized
 like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

headers/ 
\end_layout

\begin_layout Plain Layout

headers/gl/ 
\end_layout

\begin_layout Plain Layout

headers/gl/C/ 
\end_layout

\begin_layout Plain Layout

headers/gl/C/populate.sh 
\end_layout

\begin_layout Plain Layout

headers/gl/constants.cdb 
\end_layout

\begin_layout Plain Layout

headers/gl/functions.cdb 
\end_layout

\begin_layout Plain Layout

headers/gl/records.cdb 
\end_layout

\begin_layout Plain Layout

headers/gl/objc-classes.cdb 
\end_layout

\begin_layout Plain Layout

headers/gl/objc-methods.cdb 
\end_layout

\begin_layout Plain Layout

headers/gl/types.cdb 
\end_layout

\begin_layout Plain Layout

headers/gnome/ 
\end_layout

\begin_layout Plain Layout

headers/gnome/C/ 
\end_layout

\begin_layout Plain Layout

headers/gnome/C/populate.sh 
\end_layout

\begin_layout Plain Layout

headers/gnome/constants.cdb 
\end_layout

\begin_layout Plain Layout

headers/gnome/functions.cdb 
\end_layout

\begin_layout Plain Layout

headers/gnome/records.cdb 
\end_layout

\begin_layout Plain Layout

headers/gnome/objc-classes.cdb 
\end_layout

\begin_layout Plain Layout

headers/gnome/objc-methods.cdb 
\end_layout

\begin_layout Plain Layout

headers/gnome/types.cdb 
\end_layout

\begin_layout Plain Layout

headers/gtk/ 
\end_layout

\begin_layout Plain Layout

headers/gtk/C/ 
\end_layout

\begin_layout Plain Layout

headers/gtk/C/populate.sh 
\end_layout

\begin_layout Plain Layout

headers/gtk/constants.cdb 
\end_layout

\begin_layout Plain Layout

headers/gtk/functions.cdb 
\end_layout

\begin_layout Plain Layout

headers/gtk/records.cdb 
\end_layout

\begin_layout Plain Layout

headers/gtk/objc-classes.cdb 
\end_layout

\begin_layout Plain Layout

headers/gtk/objc-methods.cdb 
\end_layout

\begin_layout Plain Layout

headers/gtk/types.cdb 
\end_layout

\begin_layout Plain Layout

headers/libc/ 
\end_layout

\begin_layout Plain Layout

headers/libc/C/ 
\end_layout

\begin_layout Plain Layout

headers/libc/C/populate.sh 
\end_layout

\begin_layout Plain Layout

headers/libc/constants.cdb 
\end_layout

\begin_layout Plain Layout

headers/libc/functions.cdb 
\end_layout

\begin_layout Plain Layout

headers/libc/records.cdb 
\end_layout

\begin_layout Plain Layout

headers/libc/objc-classes.cdb 
\end_layout

\begin_layout Plain Layout

headers/libc/objc-methods.cdb 
\end_layout

\begin_layout Plain Layout

headers/libc/types.cdb 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
e.g, as a set of parallel subdirectories, each with a lowercase name and
 each of which contains a set of 6 database files and a "C" subdirectory
 which contains a shell script used in the database creation process.
\end_layout

\begin_layout Standard
As one might assume, the database files in each of these subdirectories
 contain foreign type, constant, and function definitions - as well as Objective
-C class and method info -that correspond (roughly) to the information contained
 in the header files associated with a "-dev" package in a Linux distribution.
 "libc" corresponds pretty closely to the interfaces associated with "glibc/libc
6" header files, "gl" corresponds to an "openGL+GLUT" development package,
 "gtk" and "gnome" contain interface information from the GTK+1.2 and GNOME
 libraries, respectively.
\end_layout

\begin_layout Standard
For Darwin, the "ccl:darwin-headers" directory contains a "libc" subdirectory,
 whose contents roughly correspond to those of "/usr/include" under Darwin,
 as well as subdirectories corresponding to the MacOSX Carbon and Cocoa
 frameworks.
\end_layout

\begin_layout Standard
To see the precise set of .h files used to generate the database files in
 a given interface directory, consult the corresponding "populate.sh" shell
 script (in the interface directory's "C" subdirectory.)
\end_layout

\begin_layout Standard
The intent is that this initial set can be augmented to meet local needs,
 and that this can be done in a fairly incremental fashion: one needn't
 have unrelated header files installed in order to generate interface databases
 for a package of interest.
\end_layout

\begin_layout Standard
Hopefully, this scheme will also make it easier to distribute patches and
 bug fixes.
\end_layout

\begin_layout Standard

\family typewriter
CCL
\family default
 maintains a list of directories; when looking for a foreign type, constant,
 function, or record definition, it'll consult the database files in each
 directory on that list.
 Initially, the list contains an entry for the "libc" interface directory.
 
\family typewriter
CCL
\family default
 needs to be explicitly told to look in other interface directories should
 it need to do so.
\end_layout

\begin_layout Subsection
Creating new interface directories
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Creating-new-interface-directories"

\end_inset

This example refers to "ccl:headers;", which is appropriate for LinuxPPC.
 The procedure's analogous under Darwin, where the "ccl:darwin-headers;"
 directory would be used instead.
\end_layout

\begin_layout Standard
To create a new interface directory, "foo", and a set of database files
 in that directory: 
\end_layout

\begin_layout Enumerate
Create a subdirectory of "ccl:headers;" named "foo".
\end_layout

\begin_layout Enumerate
Create a subdirectory of "ccl:headers;foo;" named "C".
\end_layout

\begin_layout Enumerate
Create a file in "ccl:headers;foo;C;" named "populate.sh".
\end_layout

\begin_deeper
\begin_layout Standard
One way of accomplishing the above steps is:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

? (close (open "ccl:headers;foo;C;populate.sh" :direction :output : if-does-not-e
xist :create :if-exists :overwrite)) 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Edit the file created above, using the "populate.sh" files in the distribution
 as guidelines.
\end_layout

\begin_deeper
\begin_layout Standard
The file might wind up looking something like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#/bin/sh 
\end_layout

\begin_layout Plain Layout

h-to-ffi.sh `foo-config -cflags` /usr/include/foo/foo.h
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Refer to Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "The-Interface-Translator"

\end_inset

 for information about running the interface translator and .ffi parser.
\end_layout

\begin_layout Standard
Assuming that all went well, there should now be .cdb files in "ccl:headers;foo;".
 You can then do 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

? (use-interface-dir :foo) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
whenever you need to access the foreign type information in those database
 files.
\end_layout

\begin_layout Section
Using Shared Libraries
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Using-Shared-Libraries"

\end_inset


\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Shared-Library-Overview"

\end_inset


\family typewriter
CCL
\family default
 provides facilities to open and close shared libraries.
\end_layout

\begin_layout Standard
"Opening" a shared library, which is done with OPEN-SHARED-LIBRARY, maps
 the library's code and data into 
\family typewriter
CCL
\family default
's address space and makes its exported symbols accessible to 
\family typewriter
CCL
\family default
.
\end_layout

\begin_layout Standard
"Closing" a shared library, which is done with CLOSE-SHARED-LIBRARY, unmaps
 the library's code and and removes the library's symbols from the global
 namespace.
\end_layout

\begin_layout Standard
A small number of shared libraries (including libc, libm, libdl under Linux,
 and the "system" library under Darwin) are opened by the lisp kernel and
 can't be closed.
\end_layout

\begin_layout Standard

\family typewriter
CCL
\family default
 uses data structures of type EXTERNAL-ENTRY-POINT to map a foreign function
 name (string) to that foreign function's 
\emph on
current
\emph default
 address.
 (A function's address may vary from session to session as different versions
 of shared libraries may load at different addresses; it may vary within
 a session for similar reasons.)
\end_layout

\begin_layout Standard
An EXTERNAL-ENTRY-POINT whose address is known is said to be 
\emph on
resolved
\emph default
.
 When an external entry point is resolved, the shared library which defines
 that entry point is noted; when a shared library is closed, the entry points
 that it defines are made unresolved.
 An EXTERNAL-ENTRY-POINT must be in the resolved state in order to be FF-CALLed;
 calling an unresolved entry point causes a "last chance" attempt to resolve
 it.
 Attempting to resolve an entrypoint that was defined in a closed library
 will cause an attempt to reopen that library.
\end_layout

\begin_layout Standard

\family typewriter
CCL
\family default
 keeps track of all libraries that have been opened in a lisp session.
 When a saved application is first started, an attempt is made to reopen
 all libraries that were open when the image was saved, and an attempt is
 made to resolve all entry points that had been referenced when the image
 was saved.
 Either of these attempts can fail "quietly", leaving some entry points
 in an unresolved state.
\end_layout

\begin_layout Standard
Linux shared libraries can be referred to either by a string which describes
 their full pathname or by their 
\emph on
soname
\emph default
, a shorter string that can be defined when the library is created.
 The dynamic linker mechanisms used in Linux make it possible (through a
 series of filesystem links and other means) to refer to a library via several
 names; the library's soname is often the most appropriate identifier.
\end_layout

\begin_layout Standard
so names are often less version-specific than other names for libraries;
 a program that refers to a library by the name "libc.so.6" is more portable
 than one which refers to "libc-2.1.3.so" or to "libc-2.2.3.so", even though the
 latter two names might each be platform-specific aliases of the first.
\end_layout

\begin_layout Standard
All of the global symbols described below are exported from the CCL package.
\end_layout

\begin_layout Subsection
Limitations and known bugs
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Limitations-and-known-bugs--1-"

\end_inset


\end_layout

\begin_layout Itemize
Don't get me started.
\end_layout

\begin_layout Itemize
The underlying functionality has a poor notion of dependency;it's not always
 possible to open libraries that depend on unopened libraries, but it's
 possible to close libraries on which other libraries depend.
 It 
\emph on
may
\emph default
 be possible to generate more explicit dependency information by parsing
 the output of the Linux ldd and ldconfig programs.
\end_layout

\begin_layout Subsection
Darwin Notes
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Darwin-Notes"

\end_inset

Darwin shared libraries come in two (basic) flavors: 
\end_layout

\begin_layout Itemize
"dylibs" (which often have the extension".dylib") are primarily intended
 to be linked against at compile/link time.
 They can be loaded dynamically,
\emph on
but can't be unloaded
\emph default
.
 Accordingly,OPEN-SHARED-LIBRARY can be used to open a .dylib-style library;calli
ng CLOSE-SHARED-LIBRARY on the result of such a call produces a warning,
 and has no other effect.
 It appears that (due to an OS bug) attempts to open .dylib shared-libraries
 that are already open can cause memory corruption unless the full pathname
 of the .dylib file is specified on the first and all subsequent calls.
\end_layout

\begin_layout Itemize
"bundles" are intended to serve as application extensions; they can be opened
 multiple times (creating multiple instances of the library!) and closed
 properly.
\end_layout

\begin_layout Standard
Thanks to Michael Klingbeil for getting both kinds of Darwin shared libraries
 working in 
\family typewriter
CCL
\family default
.
\end_layout

\begin_layout Section
The Interface Translator
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "The-Interface-Translator"

\end_inset


\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Interface-translator-overview"

\end_inset


\family typewriter
CCL
\family default
 uses an interface translation system based on the FFIGEN system, which
 is described at this page The interface translator makes the constant,
 type, structure, and function definitions in a set of C-language header
 files available to lisp code.
\end_layout

\begin_layout Standard
The basic idea of the FFIGEN scheme is to use the C compiler's frontend
 and parser to translate .h files into semantically equivalent .ffi files,
 which represent the definitions from the headers using a syntax based on
 S-expressions.
 Lisp code can then concentrate on the .ffi representatiohttp://trac.clozure.com/cc
l/wiki/BuildFFIGENn, without having to concern itself with the semantics
 of header file inclusion or the arcana of C parsing.
\end_layout

\begin_layout Standard
The original FFIGEN system used a modified version of the LCC C compiler
 to produce .ffi files.
 Since many OS header files contain GCC-specific constructs, 
\family typewriter
CCL
\family default
's translation system uses a modified version of GCC (called, somewhat confusing
ly, ffigen.)
\end_layout

\begin_layout Standard
See  
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://trac.clozure.com/ccl/wiki/BuildFFIGEN
\end_layout

\end_inset

 for information on building and installing ffigen.
\end_layout

\begin_layout Standard
A component shell script called h-to-ffi.sh reads a specified .h file (and
 optional preprocessor arguments) and writes a (hopefully) equivalent .ffi
 file to standard output, calling the ffigen program with appropriate arguments.
\end_layout

\begin_layout Standard
For each interface directory (see FIXTHIS) 
\emph on
subdir
\emph default
 distributed with 
\family typewriter
CCL
\family default
, a shell script (distributed with 
\family typewriter
CCL
\family default
 as "ccl:headers;
\emph on
subdir
\emph default
;C;populate.sh" (or some other platform-specific headers directory) calls
 h-to-ffi.sh on a large number of the header files in /usr/include (or some
 other 
\emph on
system header path
\emph default
) and creates a parallel directory tree in "ccl:headers;
\emph on
subdir
\emph default
;C;
\emph on
system
\emph default
;
\emph on
header
\emph default
;
\emph on
path
\emph default
;" (or "ccl:darwin-headers;
\emph on
subdir
\emph default
;C;
\emph on
system
\emph default
;
\emph on
header
\emph default
;
\emph on
path
\emph default
;", etc.), populating that directory with .ffi files.
\end_layout

\begin_layout Standard
A lisp function defined in "ccl:library;parse-ffi.lisp" reads the .ffi files
 in a specified interface directory 
\emph on
subdir
\emph default
 and generates new versions of the databases (files with the extension .cdb).
\end_layout

\begin_layout Standard
The CDB databases are used by the #$ and #_ reader macros and are used in
 the expansion of RREF, RLET, and related macros.
\end_layout

\begin_layout Subsection
Details: rebuilding the CDB databases, step by step
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Details--rebuilding-the-CDB-databases--step-by-step"

\end_inset


\end_layout

\begin_layout Enumerate
Ensure that the FFIGEN program is installed.
 See the"README" file generated during the FFIGEN build process for specific
 installation instructions.This example assumes LinuxPPC; for other platforms,
 substitute the appropriate headers directory.
\end_layout

\begin_layout Enumerate
Edit the "ccl:headers;
\emph on
subdir
\emph default
;C;populate.sh"shell script.
 When you're confident that the files and preprocessor options match your
 environment, cd to the"ccl:headers;
\emph on
subdir
\emph default
;C;" directory and invoke ./populate.sh.
 Repeat this step until you're able to cleanly translate all files referenced
 in the shell script.
\end_layout

\begin_layout Enumerate
Run 
\family typewriter
CCL
\family default
: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

? (require "PARSE-FFI") 
\end_layout

\begin_layout Plain Layout

PARSE-FFI
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

? (ccl::parse-standard-ffi-files :SUBDIR) 
\end_layout

\begin_layout Plain Layout

;;; lots of output ...
 after a while, shiny new .cdb files should 
\end_layout

\begin_layout Plain Layout

;;; appear in "ccl:headers;subdir;"
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
It may be necessary to call CCL::PARSE-STANDARD-FFI-FILES twice, to ensure
 that forward-references are resolved
\end_layout

\end_deeper
\begin_layout Section
Case-sensitivity of foreign names in 
\family typewriter
CCL
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Case-sensitivity-of-foreign-names-in-CCL"

\end_inset


\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Case-sensitivity-overview"

\end_inset

As of release 0.11, 
\family typewriter
CCL
\family default
 addresses the fact that foreign type, constant, record, field, and function
 nams are case-sensitive and provides mechanisms to refer to these names
 via lisp symbols.
\end_layout

\begin_layout Standard
Previous versions of 
\family typewriter
CCL
\family default
 have tried to ignore that fact, under the belief that case conflicts were
 rare and that many users (and implementors) would prefer not to deal with
 case-related issues.
 The fact that some information in the interface databases was incomplete
 or inaccessible because of this policy made it clearer that the policy
 was untenable.
 I can't claim that the approach described here is aesthetically pleasing,
 but I can honestly say that it's less unpleasant than other approaches
 that I'd thought of.
 I'd be interested to hear alternate proposals.
\end_layout

\begin_layout Standard
The issues described here have to do with how lisp symbols are used to denote
 foreign functions, constants, types, records, and fields.
 It doesn't affect how other lisp objects are sometimes used to denote foreign
 objects.
 For instance, the first argument to the EXTERNAL-CALL macros is now and
 has always been a case-sensitive string.
\end_layout

\begin_layout Subsection
Foreign constant and function names
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Foreign-constant-and-function-names"

\end_inset

The primary way of referring to foreign constant and function names in 
\family typewriter
CCL
\family default
 is via the #$ and #_ reader macros.
 These reader macro functions each read a symbol into the "OS" package,
 look up its constant or function definition in the interface database,
 and assign the value of the constant to the symbol or install a macroexpansion
 function on the symbol.
\end_layout

\begin_layout Standard
In order to observe case-sensitivity, the reader-macros now read the symbol
 with (READTABLE-CASE :PRESERVE) in effect.
\end_layout

\begin_layout Standard
This means that it's necessary to type the foreign constant or function
 name in correct case, but it isn't necessary to use any special escaping
 constructs when writing the variable name.
 For instance:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(#_read fd buf n) ; refers to foreign symbol "read"
\end_layout

\begin_layout Plain Layout

(#_READ fd buf n) ; refers to foreign symbol "READ", which may
\end_layout

\begin_layout Plain Layout

; not exist ...
\end_layout

\begin_layout Plain Layout

#$o_rdonly ; Probably doesn't exist
\end_layout

\begin_layout Plain Layout

#$O_RDONLY ; Exists on most platforms
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Foreign type, record, and field names
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Foreign-type--record--and-field-names"

\end_inset

Constructs like RLET expect a foreign type or record name to be denoted
 by a symbol (typically a keyword); RREF (and PREF) expect an "accessor"
 form, typically a keyword formed by concatenating a foreign type or record
 name with a sequence of one or more foreign field names, separated by dots.
 These names are interned by the reader as other lisp symbols are, with
 an arbitrary value of READTABLE-CASE in effect (typically :UPCASE.) It seems
 like it would be very tedious to force users to manually escape (via vertical
 bar or backslash syntax) all lowercase characters in symbols used to specify
 foreign type, record, and field names (especially given that many traditional
 POSIX structure, type, and field names are entirely lowercase.)
\end_layout

\begin_layout Standard
The approach taken by 
\family typewriter
CCL
\family default
 is to allow the symbols (keywords) used to denote foreign type, record,
 and field names to contain angle brackets (
\family typewriter
<
\family default
 and 
\family typewriter
>
\family default
).
 Such symbols are translated to foreign names via the following set of conventio
ns: 
\end_layout

\begin_layout Itemize
All instances of < and > in the symbol's pname are balanced and don't nest.
\end_layout

\begin_layout Itemize
Any alphabetic characters in the symbol's pname that aren't enclosed in
 angle brackets are treated as lower-case,regardless of the value of READTABLE-C
ASE and regardless of the case in which they were written.
\end_layout

\begin_layout Itemize
Alphabetic characters that appear within angle brackets are mapped to upper-case
, again regardless of how they were written or interned.
\end_layout

\begin_layout Standard
There may be many ways of "escaping" (with angle brackets) sequences of
 upper-case and non-lower-case characters in a symbol used to denote a foreign
 name.
 When translating in the other direction, 
\family typewriter
CCL
\family default
 always escapes the longest sequence that starts with an upper-case character
 and doesn't contain a lower-case character.
\end_layout

\begin_layout Standard
It's often preferable to use this canonical form of a foreign type name.
\end_layout

\begin_layout Standard
The accessor forms used by PREF/RREF should be viewed as a series of foreign
 type/record and field names; upper-case sequences in the component names
 should be escaped with angle brackets, but those sequences shouldn't span
 components.
 (More simply, the separating dots shouldn't be enclosed, even if both surroundi
ng characters need to be.)
\end_layout

\begin_layout Standard
Older POSIX code tends to use lower-case exclusively for type, record, and
 field names; there are only a few cases in the 
\family typewriter
CCL
\family default
 sources where mixed-case names need to be escaped.
\end_layout

\begin_layout Subsection
Examples
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Examples--1-"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

;;; Allocate a record of type "window".
 
\end_layout

\begin_layout Plain Layout

(rlet ((w :window)) ...) 
\end_layout

\begin_layout Plain Layout

;;; Allocate a record of type "Window", which is probably a 
\end_layout

\begin_layout Plain Layout

;;; different type 
\end_layout

\begin_layout Plain Layout

(rlet ((w :<w>indow)) ...) 
\end_layout

\begin_layout Plain Layout

;;; This is equivalent to the last example 
\end_layout

\begin_layout Plain Layout

(rlet ((w :<w>INDOW)))
\end_layout

\end_inset

 
\end_layout

\begin_layout Section
Reading Foreign Names
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Reading-Foreign-Names"

\end_inset


\family typewriter
CCL
\family default
 provides several reader macros to make it more convenient to handle foreign
 type, function, variable, and constant names.
 Each of these reader macros reads symbols preserving the case of the source
 text, and selects an appropriate package in which to intern the resulting
 symbol.
 These reader macros are especially useful when your Lisp code interacts
 extensively with a foreign library—for example, when using Mac OS X's Cocoa
 frameworks.
\end_layout

\begin_layout Standard
These reader macros include "#_" to read foreign function names, "#&" to
 read foreign variable names (note that in earlier versions of OpenMCL the
 reader macro "#?" was used for this same purpose), "#$" to read foreign
 constant names, "#/" to read the names of foreign Objective-C methods,
 and "#>" to read keywords that can be used as the names of types, records,
 and accessors.
\end_layout

\begin_layout Standard
All of these reader macros preserve the case of the text that they read;
 beyond that similarity, each performs some additional work, unique to each
 reader macro, to create symbols suitable for a particular use.
 For example, the function, variable, and constant reader macros intern
 the resulting symbol in the "OS" package of the running platform, but the
 reader macro for Objective-C method names interns symbols in the "NEXTSTEP-FUNC
TIONS" package.
\end_layout

\begin_layout Standard
You are likely to see these reader macros used extensively in Lisp code
 that works with foreign libraries; for example, 
\family typewriter
CCL
\family default
 IDE code, which defines numerous Objective-C classes and methods, uses
 these reader macros extensively.
\end_layout

\begin_layout Standard
For more detailed descriptions of each of these reader macros, see the Foreign-F
unction-Interface Dictionary section.
\end_layout

\begin_layout Section
The Foreign-Function-Interface Dictionary
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "Foreign-Function-Interface-Dictionary"

\end_inset


\end_layout

\begin_layout Subsection
#_
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "rm_sharpsign-underscore"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
#_
\end_layout

\end_inset

#_ ---
\end_layout

\begin_layout Standard
Reader Macro
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
Reads a symbol from the current input stream, with *PACKAGE* bound to the
 "OS" package and with readtable-case preserved.
\end_layout

\begin_layout Standard
Does a lookup on that symbol in the CCL interface database, signalling an
 error if no foreign function information can be found for the symbol in
 any active interface directory.
\end_layout

\begin_layout Standard
Notes the foreign function information, including the foreign function's
 return type, the number and type of the foreign function's required arguments,
 and an indication of whether or not the function accepts additional arguments
 (via e.g., the "varargs" mechanism in C).
\end_layout

\begin_layout Standard
Defines a macroexpansion function on the symbol, which expand macro calls
 involving the symbol into EXTERNAL-CALL forms where foreign argument type
 specifiers for required arguments and the return value specifer are provided
 from the information in the database.
\end_layout

\begin_layout Standard
Returns the symbol.
\end_layout

\begin_layout Standard
The effect of these steps is that it's possible to call foreign functions
 that take fixed numbers of arguments by simply providing argument values,
 as in:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(#_isatty fd)
\end_layout

\begin_layout Plain Layout

(#_read fd buf n)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and to call foreign functions that take variable numbers of arguments by
 specifying the types of non-required args, as in:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(with-cstrs ((format-string "the answer is: %d
\backslash

\backslash
n")) 
\end_layout

\begin_layout Plain Layout

  (#_printf format-string :int answer))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can query whether a given name is defined in the interface databases
 by appending the '?' character to the reader macro; for example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

? #_?printf
\end_layout

\begin_layout Plain Layout

T 
\end_layout

\begin_layout Plain Layout

? #_?foo 
\end_layout

\begin_layout Plain Layout

NIL 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
#&
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "rm_sharpsign-ampersand"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
#&
\end_layout

\end_inset

#& ---
\end_layout

\begin_layout Standard
Reader Macro
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
In 
\family typewriter
CCL
\family default
 1.2 and later, the #& reader macro can be used to access foreign variables;
 this functionality depends on the presence of "vars.cdb" files in the interface
 database.
 The current behavior of the #& reader macro is to:
\end_layout

\begin_layout Standard
Read a symbol from the current input stream, with *PACKAGE* bound to the
 "OS" package and with readtable-case preserved.
\end_layout

\begin_layout Standard
Use that symbol's pname to access the 
\family typewriter
CCL
\family default
 interface database, signalling an error if no appropriate foreign variable
 information can be found with that name in any active interface directory.
\end_layout

\begin_layout Standard
Use type information recorded in the database to construct a form which
 can be used to access the foreign variable, and return that form.
\end_layout

\begin_layout Standard
Please note that the set of foreign variables declared in header files may
 or may not match the set of foreign variables exported from libraries (we're
 generally talking about C and Unix here ...).
 When they do match, the form constructed by the #& reader macro manages
 the details of resolving and tracking changes to the foreign variable's
 address.
\end_layout

\begin_layout Standard
Future extensions (via prefix arguments to the reader macro) may offer additiona
l behavior; it might be convenient (for instance) to be able to access the
 address of a foreign variable without dereferencing that address.
\end_layout

\begin_layout Standard
Foreign variables in C code tend to be platform- and package-specific (the
 canonical example - "errno" - is typically not a variable when threads
 are involved.
 )
\end_layout

\begin_layout Standard
In LinuxPPC,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

? #&stderr
\end_layout

\end_inset


\end_layout

\begin_layout Standard
returns a pointer to the stdio error stream ("stderr" is a macro under OSX/Darwi
n).
\end_layout

\begin_layout Standard
On both LinuxPPC and DarwinPPC,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

? #&syserrlist
\end_layout

\end_inset


\end_layout

\begin_layout Standard
returns a pointer to a C array of C error message strings.
\end_layout

\begin_layout Standard
You can query whether a given name is defined in the interface databases
 by appending the '?' character to the reader macro; for example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

? #&?syserrlist 
\end_layout

\begin_layout Plain Layout

T 
\end_layout

\begin_layout Plain Layout

? #&?foo 
\end_layout

\begin_layout Plain Layout

NIL
\end_layout

\end_inset

 
\end_layout

\begin_layout Subsection
#$
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "rm_sharpsign-dollarsign"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
#$
\end_layout

\end_inset

#$ ---
\end_layout

\begin_layout Standard
Reader Macro
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
In 
\family typewriter
CCL
\family default
 0.14.2 and later, the #? reader macro can be used to access foreign constants;
 this functionality depends on the presence of "constants.cdb" files in the
 interface database.
 The current behavior of the #$ reader macro is to:
\end_layout

\begin_layout Standard
Read a symbol from the current input stream, with *PACKAGE* bound to the
 "OS" package and with readtable-case preserved.
\end_layout

\begin_layout Standard
Use that symbol's pname to access the 
\family typewriter
CCL
\family default
 interface database, signalling an error if no appropriate foreign constant
 information can be found with that name in any active interface directory.
\end_layout

\begin_layout Standard
Use type information recorded in the database to construct a form which
 can be used to access the foreign constant, and return that form.
\end_layout

\begin_layout Standard
Please note that the set of foreign constants declared in header files may
 or may not match the set of foreign constants exported from libraries.
 When they do match, the form constructed by the #$ reader macro manages
 the details of resolving and tracking changes to the foreign constant's
 address.
\end_layout

\begin_layout Standard
You can query whether a given name is defined in the interface databases
 by appending the '?' character to the reader macro; for example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

? #$?SO_KEEPALIVE
\end_layout

\begin_layout Plain Layout

T
\end_layout

\begin_layout Plain Layout

? #$?foo
\end_layout

\begin_layout Plain Layout

NIL
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
#/
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "rm_sharpsign-slash"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
#/
\end_layout

\end_inset

#/ ---
\end_layout

\begin_layout Standard
Reader Macro
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
In 
\family typewriter
CCL
\family default
 1.2 and later, the #/ reader macro can be used to access foreign functions
 on the Darwin platform.
 The current behavior of the #/ reader macro is to:
\end_layout

\begin_layout Standard
Read a symbol from the current input stream, with *PACKAGE* bound to the
 "NEXTSTEP-FUNCTIONS" package, with readtable-case preserved, and with any
 colons included.
\end_layout

\begin_layout Standard
Do limited sanity-checking on the resulting symbol; for example, any name
 that contains at least one colon is required also to end with a colon,
 to conform to Objective-C method-naming conventions.
\end_layout

\begin_layout Standard
Export the resulting symbol from the "NEXTSTEP-FUNCTIONS" package and return
 it.
\end_layout

\begin_layout Standard
For example, reading "#/alloc" interns and returns NEXTSTEP-FUNCTIONS:|alloc|.
 Reading "#/initWithFrame:" interns and returns NEXTSTEP-FUNCTIONS:|initWithFram
e:|.
\end_layout

\begin_layout Standard
A symbol read using this macro can be used as an operand in most places
 where an Objective-C message name can be used, such as in the (OBJ:@SELECTOR
 ...) construct.
\end_layout

\begin_layout Standard
Please note: the reader macro is not rigorous about enforcing Objective-C
 method-naming conventions.
 Despite the simple checking done by the reader macro, it may still be possible
 to use it to construct invalid names.
\end_layout

\begin_layout Standard
The act of interning a new symbol in the NEXTSTEP-FUNCTIONS package triggers
 an interface database lookup of Objective-C methods with the corresponding
 message name.
 If any such information is found, a special type of dispatching function
 is created and initialized and the new symbol is given the newly-created
 dispatching function as its function definition.
\end_layout

\begin_layout Standard
The dispatching knows how to call declared Objective-C methods defined on
 the message.
 In many cases, all methods have the same foreign type signature, and the
 dispatching function merely passes any arguments that it receives to a
 function that does an Objective-C message send with the indicated foreign
 argument and return types.
 In other cases, where different Objective-C messages have different type
 signatures, the dispatching function tries to choose a function that handles
 the right type signature based on the class of the dispatching function's
 first argument.
\end_layout

\begin_layout Standard
If new information about Objective-C methods is introduced (e.g., by using
 additional interface files or as Objective-C methods are defined from lisp),
 the dispatch function is reinitialized to recognize newly-introduced foreign
 type signatures.
\end_layout

\begin_layout Standard
The argument and result coercion that the bridge has traditionally supported
 is supported by the new mechanism (e.g., :<BOOL> arguments can be specified
 as lisp booleans and :<BOOL> results are returned as lisp boolean values,
 and an argument value of NIL is coerced to a null pointer if the corresponding
 argument type is :ID.
\end_layout

\begin_layout Standard
Some Objective-C methods accept variable numbers of arguments; the foreign
 types of non-required arguments are determined by the lisp types of those
 arguments (e.g., integers are passed as integers, floats as floats, pointers
 as pointers, record types by reference.)
\end_layout

\begin_layout Standard
Examples:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

;;; #/alloc is a known message.
 
\end_layout

\begin_layout Plain Layout

? #'#/alloc 
\end_layout

\begin_layout Plain Layout

#<OBJC-DISPATCH-FUNCTION NEXTSTEP-FUNCTIONS:|alloc| #x300040E94EBF> 
\end_layout

\begin_layout Plain Layout

;;; Sadly, #/foo is not ...
 
\end_layout

\begin_layout Plain Layout

? #'#/foo 
\end_layout

\begin_layout Plain Layout

> Error: Undefined function: NEXTSTEP-FUNCTIONS:|foo|
\end_layout

\begin_layout Plain Layout

;;; We can send an "init" message to a newly-allocated instance of 
\end_layout

\begin_layout Plain Layout

;;; "NSObject" by:
\end_layout

\begin_layout Plain Layout

(send (send ns:ns-object 'alloc) 'init)
\end_layout

\begin_layout Plain Layout

;;; or by
\end_layout

\begin_layout Plain Layout

(#/init (#/alloc ns:ns-object)) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Objective-C methods that "return" structures return them as garbage-collectable
 pointers when called via dispatch functions.
 For example, if "my-window" is an NS:NS-WINDOW instance, then 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(#/frame my-window) 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
returns a garbage-collectable pointer to a structure that describes that
 window's frame rectangle.
 This convention means that there's no need to use SLET or special structure-ret
urning message send syntax; keep in mind, though, that #_malloc, #_free,
 and the GC are all involved in the creation and eventual destruction of
 structure-typed return values.
 In some programs these operations may have an impact on performance.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
#>
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "rm_sharpsign-greaterthan"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
#>
\end_layout

\end_inset

#> ---
\end_layout

\begin_layout Standard
Reader Macro
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
In 
\family typewriter
CCL
\family default
 1.2 and later, the #> reader macro reads the following text as a keyword,
 preserving the case of the text.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

? #>FooBar 
\end_layout

\begin_layout Plain Layout

:<F>OO<B>AR 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The resulting keyword can be used as the name of foreign types, records,
 and accessors.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
CLOSE-SHARED-LIBRARY
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "f_close-shared-library"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
close-shared-library
\end_layout

\end_inset

CLOSE-SHARED-LIBRARY --- Stops using a shared library, informing the operating
 system that it can be unloaded if appropriate.
\end_layout

\begin_layout Standard
Function
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard
 close-shared-library library &key completely
\end_layout

\begin_layout Subsubsection*
Values
\end_layout

\begin_layout Description
library either an object of type SHLIB, or a string which designates one
 by its so-name.
 
\end_layout

\begin_layout Description
completely a boolean.
 The default is T.
 
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
\noindent
If 
\family typewriter
completely
\family default
 is T, sets the reference count of 
\family typewriter
library
\family default
 to 0.
 Otherwise, decrements it by 1.
 In either case, if the reference count becomes 0, 
\family typewriter
close-shared-library
\family default
 frees all memory resources consumed 
\family typewriter
library
\family default
 and causes any EXTERNAL-ENTRY-POINTs known to be defined by it to become
 unresolved.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
DEFCALLBACK
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "m_defcallback"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
defcallback
\end_layout

\end_inset

DEFCALLBACK ---
\end_layout

\begin_layout Standard
Macro
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard
 defcallback name (arg-type-specifier var* &optional result-type-specifier)
 &body body 
\end_layout

\begin_layout Subsubsection*
Values
\end_layout

\begin_layout Description
name A symbol which can be made into a special variable 
\end_layout

\begin_layout Description
arg-type-specifer One of the foreign argument-type keywords, described above,
 or an equivalent foreign type specifier.
 In addition, if the keyword :WITHOUT-INTERRUPTS is specified, the callback
 will be executed with lisp interrupts disabled if the corresponding var
 is non-NIL.
 If :WITHOUT-INTERRUPTS is specified more than once, the rightmost instance
 wins.
 
\end_layout

\begin_layout Description
var A symbol (lisp variable), which will be bound to a value of the specified
 type.
 
\end_layout

\begin_layout Description
body A sequence of lisp forms, which should return a value which can be
 coerced to the specified result-type.
 
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
\noindent
Proclaims 
\family typewriter
name
\family default
 to be a special variable; sets its value to a MACPTR which, when called
 by foreign code, calls a lisp function which expects foreign arguments
 of the specified types and which returns a foreign value of the specified
 result type.
 Any argument variables which correspond to foreign arguments of type :ADDRESS
 are bound to stack-allocated MACPTRs.
\end_layout

\begin_layout Standard
If 
\family typewriter
name
\family default
 is already a callback function pointer, its value is not changed; instead,
 it's arranged that an updated version of the lisp callback function will
 be called.
 This feature allows for callback functions to be redefined incrementally,
 just like Lisp functions are.
\end_layout

\begin_layout Standard

\family typewriter
defcallback
\family default
 returns the callback pointer, e.g., the value of 
\family typewriter
name
\family default
.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
DEF-FOREIGN-TYPE
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "m_def-foreign-type"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
def-foreign-type
\end_layout

\end_inset

DEF-FOREIGN-TYPE ---
\end_layout

\begin_layout Standard
Macro
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard
 def-foreign-type name foreign-type-spec 
\end_layout

\begin_layout Subsubsection*
Values
\end_layout

\begin_layout Description
name NIL or a keyword; the keyword may contain escaping constructs.
 
\end_layout

\begin_layout Description
foreign-type-spec A foreign type specifier, whose syntax is (loosely) defined
 above.
 
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
\noindent
If name is non-NIL, defines name to be an alias for the foreign type specified
 by foreign-type-spec.
 If foreign-type-spec is a named structure or union type, additionally defines
 that structure or union type.
\end_layout

\begin_layout Standard
If name is NIL, foreign-type-spec must be a named foreign struct or union
 definition, in which case the foreign structure or union definition is
 put in effect.
\end_layout

\begin_layout Standard
Note that there are two separate namespaces for foreign type names, one
 for the names of ordinary types and one for the names of structs and unions.
 Which one 
\family typewriter
name
\family default
 refers to depends on 
\family typewriter
foreign-type-spec
\family default
 in the obvious manner.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
EXTERNAL
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "m_external"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
external
\end_layout

\end_inset

EXTERNAL --- Resolves a reference to an external symbol which is defined
 in a shared library.
\end_layout

\begin_layout Standard
Macro
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard
 external name => entry 
\end_layout

\begin_layout Subsubsection*
Values
\end_layout

\begin_layout Description
name a simple-string which names an external symbol.
 Case-sensitive.
 
\end_layout

\begin_layout Description
entry an object of type EXTERNAL-ENTRY-POINT which maintains the address
 of the foreign symbol named by 
\family typewriter
name
\family default
.
 
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
\noindent
If there is already an EXTERNAL-ENTRY-POINT for the symbol named by 
\family typewriter
name
\family default
, finds it and returns it.
 If not, creates one and returns it.
\end_layout

\begin_layout Standard
Tries to resolve the entry point to a memory address, and identify the containin
g library.
\end_layout

\begin_layout Standard
Be aware that under Darwin, external functions which are callable from C
 have underscores prepended to their names, as in "_fopen".
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
EXTERNAL-CALL
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "m_external-call"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
external-call
\end_layout

\end_inset

EXTERNAL-CALL ---
\end_layout

\begin_layout Standard
Macro
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard
 external-call name arg-type-specifier arg* &optional result-type-specifier
 
\end_layout

\begin_layout Subsubsection*
Values
\end_layout

\begin_layout Description
name A lisp string.
 See external, above.
 
\end_layout

\begin_layout Description
arg-type-specifer One of the foreign argument-type keywords, described above,
 or an equivalent foreign type specifier.
 
\end_layout

\begin_layout Description
arg A lisp value of type indicated by the corresponding arg-type-specifier
 
\end_layout

\begin_layout Description
result-type-specifier One of the foreign argument-type keywords, described
 above, or an equivalent foreign type specifier.
 
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
\noindent
Calls the foreign function at the address obtained by resolving the external-ent
ry-point associated with name, passing the values of each arg as a foreign
 argument of type indicated by the corresponding arg-type-specifier.
 Returns the foreign function result (coerced to a Lisp object of type indicated
 by result-type-specifier), or NIL if result-type-specifer is :VOID or NIL
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
%FF-CALL
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "f_Pff-call"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
%ff-call
\end_layout

\end_inset

%FF-CALL ---
\end_layout

\begin_layout Standard
Function
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard
entrypoint arg-type-keyword arg* &optional result-type-keyword 
\end_layout

\begin_layout Subsubsection*
Values
\end_layout

\begin_layout Description
entrypoint A fixnum or MACPTR 
\end_layout

\begin_layout Description
arg-type-keyword One of the foreign argument-type keywords, described above
 
\end_layout

\begin_layout Description
arg A lisp value of type indicated by the corresponding arg-type-keyword
 
\end_layout

\begin_layout Description
result-type-keyword One of the foreign argument-type keywords, described
 above 
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
\noindent
Calls the foreign function at address entrypoint passing the values of each
 arg as a foreign argument of type indicated by the corresponding arg-type-keywo
rd.
 Returns the foreign function result (coerced to a Lisp object of type indicated
 by result-type-keyword), or NIL if result-type-keyword is :VOID or NIL
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
FF-CALL
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "m_ff-call"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
ff-call
\end_layout

\end_inset

FF-CALL ---
\end_layout

\begin_layout Standard
Macro
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard
 ff-call entrypoint arg-type-specifier arg* &optional result-type-specifier
 
\end_layout

\begin_layout Subsubsection*
Values
\end_layout

\begin_layout Description
entrypoint A fixnum or MACPTR 
\end_layout

\begin_layout Description
arg-type-specifer One of the foreign argument-type keywords, described above,
 or an equivalent foreign type specifier.
 
\end_layout

\begin_layout Description
arg A lisp value of type indicated by the corresponding arg-type-specifier
 
\end_layout

\begin_layout Description
result-type-specifier One of the foreign argument-type keywords, described
 above, or an equivalent foreign type specifier.
 
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
\noindent
Calls the foreign function at address entrypoint passing the values of each
 arg as a foreign argument of type indicated by the corresponding arg-type-speci
fier.
 Returns the foreign function result (coerced to a Lisp object of type indicated
 by result-type-specifier), or NIL if result-type-specifer is :VOID or NIL
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
FOREIGN-SYMBOL-ADDRESS
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "f_foreign-symbol-address"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
foreign-symbol-address
\end_layout

\end_inset

FOREIGN-SYMBOL-ADDRESS ---
\end_layout

\begin_layout Standard
Function
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard
 foreign-symbol-address name 
\end_layout

\begin_layout Subsubsection*
Values
\end_layout

\begin_layout Description
name A lisp string.
 
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
\noindent
Tries to resolve the address of the foreign symbol name.
 If successful, returns that address encapsulated in a MACPTR, else returns
 NIL.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
FOREIGN-SYMBOL-ENTRY
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "f_foreign-symbol-entry"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
foreign-symbol-entry
\end_layout

\end_inset

FOREIGN-SYMBOL-ENTRY ---
\end_layout

\begin_layout Standard
Function
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard
 foreign-symbol-entry name 
\end_layout

\begin_layout Subsubsection*
Values
\end_layout

\begin_layout Description
name A lisp string.
 
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
\noindent
Tries to resolve the address of the foreign symbol name.
 If successful, returns a fixnum representation of that address, else returns
 NIL.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
FREE
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "f_free"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
free
\end_layout

\end_inset

FREE ---
\end_layout

\begin_layout Standard
Function
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard
 free ptr 
\end_layout

\begin_layout Subsubsection*
Values
\end_layout

\begin_layout Description
ptr A 
\family typewriter
MACPTR
\family default
 that points to a block of foreign, heap-allocated memory.
 
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
\noindent
In 
\family typewriter
CCL
\family default
 1.2 and later, the 
\family typewriter
CCL:FREE
\family default
 function invokes the foreign 
\family typewriter
free
\family default
 function from the platform's standard C library to deallocate a block of
 foreign memory.
\end_layout

\begin_layout Standard
Previous versions of 
\family typewriter
CCL
\family default
 implemented this function, but it was not exported.
\end_layout

\begin_layout Standard
If the argument to 
\family typewriter
CCL:FREE
\family default
 is a gcable pointer (for example, an object returned by 
\family typewriter
MAKE-GCABLE-RECORD
\family default
) then 
\family typewriter
CCL:FREE
\family default
 informs the garbage collector that the foreign memory has been deallocated
 before calling the foreign 
\family typewriter
free
\family default
 function.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
MAKE-HEAP-IVECTOR
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "f_make-heap-ivector"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
make-heap-ivector
\end_layout

\end_inset

MAKE-HEAP-IVECTOR ---
\end_layout

\begin_layout Standard
Function
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard
 make-heap-ivector element-count element-type => vector macptr size 
\end_layout

\begin_layout Subsubsection*
Values
\end_layout

\begin_layout Description
element-count A positive integer.
 
\end_layout

\begin_layout Description
element-type A type specifier.
 
\end_layout

\begin_layout Description
vector A lisp vector.
 The initial contents are undefined.
 
\end_layout

\begin_layout Description
mactpr A pointer to the first byte of data stored in the vector.
 
\end_layout

\begin_layout Description
size The size of the returned vector in octets.
 
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
\noindent
An "ivector" is a one-dimensional array that's specialized to a numeric
 or character element type.
\end_layout

\begin_layout Standard

\family typewriter
MAKE-HEAP-IVECTOR
\family default
 allocates an ivector in foreign memory.
 The GC will never move this vector, and will in fact not pay any attention
 to it at all.
 The returned pointer to it can therefore be passed safely to foreign code.
\end_layout

\begin_layout Standard
The vector must be explicitly deallocated with 
\family typewriter
DISPOSE-HEAP-IVECTOR
\family default
.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
MAKE-GCABLE-RECORD
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "m_makegcable--record"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
make-gcable-record
\end_layout

\end_inset

MAKE-GCABLE-RECORD ---
\end_layout

\begin_layout Standard
Macro
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard
 make-gcable-record typespec &rest initforms => result 
\end_layout

\begin_layout Subsubsection*
Values
\end_layout

\begin_layout Description
typespec A foreign type specifier, or a keyword which is used as the name
 of a foreign struct or union.
 
\end_layout

\begin_layout Description
initforms If the type denoted by 
\family typewriter
typespec
\family default
 is scalar, a single value appropriate for that type; otherwise, a list
 of alternating field names and values appropriate for the types of those
 fields.
 
\end_layout

\begin_layout Description
result A macptr which encapsulates the address of a newly-allocated record
 on the foreign heap.
 The foreign object returned by 
\family typewriter
make-gcable-record
\family default
 is freed when the garbage collector determines that the 
\family typewriter
MACPTR
\family default
 object that describes it is unreachable.
 
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
\noindent
Allocates a block of foreign memory suitable to hold the foreign type described
 by 
\family typewriter
typespec
\family default
, in the same manner as MAKE-RECORD.
 In addition, 
\family typewriter
MAKE-GCABLE-RECORD
\family default
 marks the returned object gcable; in other words, it informs the garbage
 collector that it may reclaim the object when it becomes unreachable.
\end_layout

\begin_layout Standard
In all other respects, 
\family typewriter
MAKE-GCABLE-RECORD
\family default
 works the same way as MAKE-RECORD
\end_layout

\begin_layout Standard
When using gcable pointers, it's important to remember the distinction between
 a 
\family typewriter
MACPTR
\family default
 object (which is a lisp object, more or less like any other) and the block
 of foreign memory that the 
\family typewriter
MACPTR
\family default
 object points to.
 If a gcable 
\family typewriter
MACPTR
\family default
 object is the only thing in the world (lisp world or foreign world) that
 references the underlying block of foreign memory, then freeing the foreign
 memory when it becomes impossible to reference it is convenient and sane.
 If other lisp 
\family typewriter
MACPTR
\family default
s reference the underlying block of foreign memory or if the address of
 that foreign memory is passed to and retained by foreign code, having the
 GC free the memory may have unpleasant consequences if those other references
 are used.
\end_layout

\begin_layout Standard
Take care, therefore, not to create a gcable record unless you are sure
 that the returned 
\family typewriter
MACPTR
\family default
 will be the only reference to the allocated memory that will ever be used.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
MAKE-RECORD 
\begin_inset CommandInset label
LatexCommand label
name "anchor_make-record"

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "m_make-record"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
make-record
\end_layout

\end_inset

MAKE-RECORD ---
\end_layout

\begin_layout Standard
Macro
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard
make-record typespec &rest initforms => result 
\end_layout

\begin_layout Subsubsection*
Values
\end_layout

\begin_layout Description
typespec A foreign type specifier, or a keyword which is used as the name
 of a foreign struct or union.
 
\end_layout

\begin_layout Description
initforms If the type denoted by 
\family typewriter
typespec
\family default
 is scalar, a single value appropriate for that type; otherwise, a list
 of alternating field names and values appropriate for the types of those
 fields.
 
\end_layout

\begin_layout Description
result A macptr which encapsulates the address of a newly-allocated record
 on the foreign heap.
 
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
\noindent
Expands into code which allocates and initializes an instance of the type
 denoted by 
\family typewriter
typespec
\family default
, on the foreign heap.
 The record is allocated using the C function 
\family typewriter
malloc
\family default
, and the user of 
\family typewriter
make-record
\family default
 must explicitly call the function 
\family typewriter
CCL:FREE
\family default
 to deallocate the record, when it is no longer needed.
\end_layout

\begin_layout Standard
If 
\family typewriter
initforms
\family default
 is provided, its value or values are used in the initialization.
 When the type is a scalar, 
\family typewriter
initforms
\family default
 is either a single value which can be coerced to that type, or no value,
 in which case binary 0 is used.
 When the type is a struct, 
\family typewriter
initforms
\family default
 is a list, giving field names and the values for each.
 Each field is treated in the same way as a scalar is: If a value for it
 is given, it must be coerceable to the field's type; if not, binary 0 is
 used.
\end_layout

\begin_layout Standard
When the type is an array, 
\family typewriter
initforms
\family default
 may not be provided, because 
\family typewriter
make-record
\family default
 cannot initialize its values.
 
\family typewriter
make-record
\family default
 is also unable to initialize fields of a struct which are themselves structs.
 The user of 
\family typewriter
make-record
\family default
 should set these values by another means.
\end_layout

\begin_layout Standard
A possibly-significant limitation is that it must be possible to find the
 foreign type at the time the macro is expanded; 
\family typewriter
make-record
\family default
 signals an error if this is not the case.
\end_layout

\begin_layout Subsubsection*
Notes
\end_layout

\begin_layout Standard
It is inconvenient that 
\family typewriter
make-record
\family default
 is a macro, because this means that 
\family typewriter
typespec
\family default
 cannot be a variable; it must be an immediate value.
\end_layout

\begin_layout Standard
If it weren't for this requirement, 
\family typewriter
make-record
\family default
 could be a function.
 However, that would mean that any stand-alone application using it would
 have to include a copy of the interface database (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "The-Interface-Database"

\end_inset

), which is undesirable because it's large.
\end_layout

\begin_layout Subsection
OPEN-SHARED-LIBRARY
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "f_open-shared-library"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
open-shared-library
\end_layout

\end_inset

OPEN-SHARED-LIBRARY --- Asks the operating system to load a shared library
 for 
\family typewriter
CCL
\family default
 to use.
\end_layout

\begin_layout Standard
Function
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard
 open-shared-library name => library 
\end_layout

\begin_layout Subsubsection*
Values
\end_layout

\begin_layout Description
name A SIMPLE-STRING which is presumed to be the so-name of or a filesystem
 path to the library.
 
\end_layout

\begin_layout Description
library An object of type SHLIB which describes the library denoted by 
\family typewriter
name
\family default
.
 
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
\noindent
If the library denoted by 
\family typewriter
name
\family default
 can be loaded by the operating system, returns an object of type SHLIB
 that describes the library; if the library is already open, increments
 a reference count.
 If the library can't be loaded, signals a SIMPLE-ERROR which contains an
 often-cryptic message from the operating system.
\end_layout

\begin_layout Subsubsection*
Examples
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

;;; Try to do something simple.
 
\end_layout

\begin_layout Plain Layout

? (open-shared-library "libgtk.so") 
\end_layout

\begin_layout Plain Layout

> Error: Error opening shared library "libgtk.so": /usr/lib/libgtk.so: undefined
 symbol: gdkthreadsmutex 
\end_layout

\begin_layout Plain Layout

> While executing: OPEN-SHARED-LIBRARY
\end_layout

\begin_layout Plain Layout

;;; Grovel around, curse, and try to find out where "gdkthreadsmutex" 
\end_layout

\begin_layout Plain Layout

;;; might be defined.
 Then try again:
\end_layout

\begin_layout Plain Layout

? (open-shared-library "libgdk.so") #<SHLIB libgdk.so #x3046DBB6>
\end_layout

\begin_layout Plain Layout

? (open-shared-library "libgtk.so") #<SHLIB libgtk.so #x3046DC86>
\end_layout

\begin_layout Plain Layout

;;; Reference an external symbol defined in one of those libraries.
\end_layout

\begin_layout Plain Layout

? (external "gtkmain") #<EXTERNAL-ENTRY-POINT "gtkmain" (#x012C3004) libgtk.so
 #x3046FE46>
\end_layout

\begin_layout Plain Layout

;;; Close those libraries.
\end_layout

\begin_layout Plain Layout

? (close-shared-library "libgtk.so") T
\end_layout

\begin_layout Plain Layout

? (close-shared-library "libgdk.so") T
\end_layout

\begin_layout Plain Layout

;;; Reference the external symbol again.
\end_layout

\begin_layout Plain Layout

? (external "gtkmain") #<EXTERNAL-ENTRY-POINT "gtkmain" unresolved libgtk.so
 #x3046FE46>
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Notes
\end_layout

\begin_layout Standard
It would be helpful to describe what an soname is and give examples of one.
\end_layout

\begin_layout Standard
Does the SHLIB still get returned if the library is already open?
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
PREF
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "m_pref"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
pref
\end_layout

\end_inset

PREF ---
\end_layout

\begin_layout Standard
Macro
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard
 pref ptr accessor-form 
\end_layout

\begin_layout Subsubsection*
Values
\end_layout

\begin_layout Description
ptr a MACPTR.
 
\end_layout

\begin_layout Description
accessor-form a keyword which names a foreign type or record, as described
 in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "Foreign-type--record--and-field-names"

\end_inset

.
 
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
\noindent
References an instance of a foreign type (or a component of a foreign type)
 accessible via ptr.
\end_layout

\begin_layout Standard
Expands into code which references the indicated scalar type or component,
 or returns a pointer to a composite type.
\end_layout

\begin_layout Standard
PREF can be used with SETF.
\end_layout

\begin_layout Standard
RREF is a deprecated alternative to PREF.
 It accepts a :STORAGE keyword and rather loudly ignores it.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
%REFERENCE-EXTERNAL-ENTRY-POINT
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "f_Preference-external-entry-point"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
%reference-external-entry-point
\end_layout

\end_inset

%REFERENCE-EXTERNAL-ENTRY-POINT ---
\end_layout

\begin_layout Standard
Function
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard
  
\end_layout

\begin_layout Subsubsection*
Values
\end_layout

\begin_layout Description
eep An EXTERNAL-ENTRY-POINT, as obtained by the EXTERNAL macro.
 
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
\noindent
Tries to resolve the address of the EXTERNAL-ENTRY-POINT eep; returns a
 fixnum representation of that address if successful, else signals an error.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
RLET 
\begin_inset CommandInset label
LatexCommand label
name "anchor_rlet"

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "m_rlet"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
rlet
\end_layout

\end_inset

RLET ---
\end_layout

\begin_layout Standard
Macro
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard
 rlet (var typespec &rest initforms)* &body body 
\end_layout

\begin_layout Subsubsection*
Values
\end_layout

\begin_layout Description
var A symbol (a lisp variable) 
\end_layout

\begin_layout Description
typespec A foreign type specifier or foreign record name.
 
\end_layout

\begin_layout Description
initforms As described above, for  MAKE-RECORD  
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
\noindent
Executes 
\family typewriter
body
\family default
 in an environment in which each var is bound to a MACPTR encapsulating
 the address of a stack-allocated foreign memory block, allocated and initialize
d from typespec and initforms as per  MAKE-RECORD .
 Returns whatever value(s) 
\family typewriter
body
\family default
 returns.
\end_layout

\begin_layout Standard
Record fields that aren't explicitly initialized have unspecified contents.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
RLETZ
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "m_rletz"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
rletz
\end_layout

\end_inset

RLETZ ---
\end_layout

\begin_layout Standard
Macro
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard
 rletz (var typespec &rest initforms)* &body body 
\end_layout

\begin_layout Subsubsection*
Values
\end_layout

\begin_layout Description
var A symbol (a lisp variable) 
\end_layout

\begin_layout Description
typespec A foreign type specifier or foreign record name.
 
\end_layout

\begin_layout Description
initforms As described above, for ccl:make-record 
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
\noindent
Executes body in an environment in which each var is bound to a MACPTR encapsula
ting the address of a stack-allocated foreign memory block, allocated and
 initialized from typespec and initforms as ccl:make-record.
\end_layout

\begin_layout Standard
Returns whatever value(s) body returns.
\end_layout

\begin_layout Standard
Unlike rlet, record fields that aren't explicitly initialized are set to
 binary 0.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
TERMINATE-WHEN-UNREACHABLE
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "f_terminate-when-unreachable"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
terminate-when-unreachable
\end_layout

\end_inset

TERMINATE-WHEN-UNREACHABLE ---
\end_layout

\begin_layout Standard
Function
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard
 terminate-when-unreachable object 
\end_layout

\begin_layout Subsubsection*
Values
\end_layout

\begin_layout Description
object A CLOS object of a class for which there exists a method of the generic
 function 
\family typewriter
ccl:terminate
\family default
.
 
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
\noindent
The "termination" mechanism is a way to have the garbage collector run a
 function right before an object is about to become garbage.
 It is very similar to the "finalization" mechanism which Java has.
 It is not standard Common Lisp, although other Lisp implementations have
 similar features.
 It is useful when there is some sort of special cleanup, deallocation,
 or releasing of resources which needs to happen when a certain object is
 no longer being used.
\end_layout

\begin_layout Standard
When the garbage collector discovers that an object is no longer referred
 to anywhere in the program, it deallocates that object, freeing its memory.
 However, if 
\family typewriter
ccl:terminate-when-unreachable
\family default
 has been called on the object at any time, the garbage collector first
 invokes the generic function 
\family typewriter
ccl:terminate
\family default
, passing it the object as a parameter.
\end_layout

\begin_layout Standard
Therefore, to make termination do something useful, you need to define a
 method on 
\family typewriter
ccl:terminate
\family default
.
\end_layout

\begin_layout Standard
Because calling 
\family typewriter
ccl:terminate-when-unreachable
\family default
 only affects a single object, rather than all objects of its class, you
 may wish to put a call to it in the 
\family typewriter
initialize-instance
\family default
 method of a class.
 Of course, this is only appropriate if you do in fact want to use termination
 for all objects of a given class.
\end_layout

\begin_layout Subsubsection*
Example
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(defclass resource-wrapper () ((resource :accessor resource)))
\end_layout

\begin_layout Plain Layout

(defmethod initialize-instance :after ((x resource-wrapper) &rest initargs)
 (ccl:terminate-when-unreachable x))
\end_layout

\begin_layout Plain Layout

(defmethod ccl:terminate ((x resource-wrapper)) (when (resource x) (deallocate
 (resource x))))
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
UNUSE-INTERFACE-DIR
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "f_unuse-interface-dir"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
unuse-interface-dir
\end_layout

\end_inset

UNUSE-INTERFACE-DIR ---
\end_layout

\begin_layout Standard
Function
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard
 unuse-interface-dir dir-id 
\end_layout

\begin_layout Subsubsection*
Values
\end_layout

\begin_layout Description
dir-id A keyword whose pname, mapped to lower case, names a subdirectory
 of "ccl:headers;" (or "ccl:darwin-headers;") 
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
\noindent
Tells 
\family typewriter
CCL
\family default
 to remove the interface directory denoted by dir-id from the list of interface
 directories which are consulted for foreign type and function information.
 Returns T if the directory was on the search list, NIL otherwise.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
USE-INTERFACE-DIR
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "f_use-interface-dir"

\end_inset


\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
use-interface-dir
\end_layout

\end_inset

USE-INTERFACE-DIR ---
\end_layout

\begin_layout Standard
Function
\end_layout

\begin_layout Subsubsection*
Synopsis
\end_layout

\begin_layout Standard
 use-interface-dir dir-id 
\end_layout

\begin_layout Subsubsection*
Values
\end_layout

\begin_layout Description
dir-id A keyword whose pname, mapped to lower case, names a subdirectory
 of "ccl:headers;" (or "ccl:darwin-headers;") 
\end_layout

\begin_layout Subsubsection*
Description
\end_layout

\begin_layout Standard
\noindent
Tells 
\family typewriter
CCL
\family default
 to add the interface directory denoted by dir-id to the list of interface
 directories which it consults for foreign type and function information.
 Arranges that that directory is searched before any others.
\end_layout

\begin_layout Standard
Note that 
\family typewriter
use-interface-dir
\family default
 merely adds an entry to a search list.
 If the named directory doesn't exist in the file system or doesn't contain
 a set of database files, a runtime error may occur when 
\family typewriter
CCL
\family default
 tries to open some database file in that directory, and it will try to
 open such a database file whenever it needs to find any foreign type or
 function information.
 UNUSE-INTERFACE-DIR may come in handy in that case.
\end_layout

\begin_layout Subsubsection*
Examples
\end_layout

\begin_layout Standard
One typically wants interface information to be available at compile-time
 (or, in many cases, at read-time).
 A typical idiom would be:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(eval-when (:compile-toplevel :execute) (use-interface-dir :GTK))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Using the :GTK interface directory makes available information on foreign
 types, functions, and constants.
 It's generally necessary to load foreign libraries before actually calling
 the foreign code, which for GTK can be done like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(load-gtk-libraries)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It should now be possible to do things like:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(#_gtkwidgetdestroy w)
\end_layout

\end_inset


\end_layout

\end_body
\end_document
