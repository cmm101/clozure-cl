<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [
<!ENTITY rest "<varname>&amp;rest</varname>">
<!ENTITY key "<varname>&amp;key</varname>">
<!ENTITY optional "<varname>&amp;optional</varname>">
<!ENTITY body "<varname>&amp;body</varname>">
<!ENTITY aux "<varname>&amp;aux</varname>">
<!ENTITY allow-other-keys "<varname>&amp;allow-other-keys</varname>">
]>

  <chapter id="Creating-Your-Own-Stream-Classes-with-Gray-Streams">
    <title>Creating Your Own Stream Classes with Gray Streams</title>

    <sect1 id="Streams-Overview">
      <title>Overview</title>
      <para>This chapter is still being written and revised, because
      it is woefully incomplete.  The dictionary section currently
      only lists a couple functions.  Caveat lector.</para>
      <para>Gray streams are an extension to Common Lisp.  They were
      proposed for standardization by David Gray (the astute reader
      now understands their name) quite some years ago, but not
      accepted, because they had not been tried sufficiently to find
      conceptual problems with them.</para>
      <para>They have since been implemented by quite a few modern
      Lisp implementations.  However, they do indeed have some
      inadequacies, and each implementation has addressed these in
      different ways.  The situation today is that it's difficult to
      even find out how to get started using Gray streams.  This is
      why standards are important.</para>
      <para>Here's a list of some classes which you might wish for
      your new stream class to inherit from:</para>
 
      <simplelist>
	<member>fundamental-stream</member>
	<member>fundamental-input-stream</member>
	<member>fundamental-output-stream</member>
	<member>fundamental-character-stream</member>
	<member>fundamental-binary-stream</member>
	<member>fundamental-character-input-stream</member>
	<member>fundamental-character-output-stream</member>
	<member>fundamental-binary-input-stream</member>
	<member>fundamental-binary-output-stream</member>
	<member>ccl::buffered-stream-mixin</member>
	<member>ccl::buffered-input-stream-mixin</member>
	<member>ccl::buffered-output-stream-mixin</member>
	<member>ccl::buffered-io-stream-mixin</member>
	<member>ccl::buffered-character-input-stream-mixin</member>
	<member>ccl::buffered-character-output-stream-mixin</member>
	<member>ccl::buffered-character-io-stream-mixin</member>
	<member>ccl::buffered-binary-input-stream-mixin</member>
	<member>ccl::buffered-binary-output-stream-mixin</member>
	<member>ccl::buffered-binary-io-stream-mixin</member>
	<member>file-stream</member>
	<member>file-input-stream</member>
	<member>file-output-stream</member>
	<member>file-io-stream</member>
	<member>file-character-input-stream</member>
	<member>file-character-output-stream</member>
	<member>file-charcter-io-stream</member>
	<member>file-binary-input-stream</member>
	<member>file-binary-output-stream</member>
	<member>file-binary-io-stream</member>
	<member>ccl::fd-stream</member>
	<member>ccl::fd-input-stream</member>
	<member>ccl::fd-output-stream</member>
	<member>ccl::fd-io-stream</member>
	<member>ccl::fd-character-input-stream</member>
	<member>ccl::fd-character-output-stream</member>
	<member>ccl::fd-character-io-stream</member>
	<member>ccl::fd-binary-input-stream</member>
	<member>ccl::fd-binary-output-stream</member>
	<member>ccl::fd-binary-io-stream</member>
      </simplelist>

      <para>All of these are defined in ccl/level-1/l1-streams.lisp,
      except for the ccl:file-* ones, which are in
      ccl/level-1/l1-sysio.lisp.</para>
      <para>According to the original Gray streams proposal, you
      should inherit from the most specific of the fundamental-*
      classes which applies.  Using OpenMCL, though, if you want
      buffering for better performance, which, unless you know of some
      reason you wouldn't, you do, you should instead inherit from the
      appropriate ccl::buffered-* class The buffering you get this way
      is exactly the same as the buffering which is used on ordinary,
      non-Gray streams, and force-output will work properly on
      it.</para>
      <para>Notice that -mixin suffix in the names of all the
      ccl::buffered-* classes?  The suffix means that this class is
      not "complete" by itself; you still need to inherit from a
      fundamental-* stream, even if you also inherit from a *-mixin
      stream.  You might consider making your own class like this.
      ....  Except that they do inherit from the fundamental-*
      streams, that's weird.</para>
      <para>If you want to be able to create an instance of your class
      with the :class argument to (open) and (with-open-file), you
      should make it inherit from one of the file-* classes.  If you
      do this, it's not necessary to inherit from any of the other
      classes (though it won't hurt anything), since the file-*
      classes already do.</para>
      <para>When you inherit from the file-* classes, you can use
      (call-next-method) in any of your methods to get the standard
      behaviour.  This is especially useful if you want to create a
      class which performs some simple filtering operation, such as
      changing everything to uppercase or to a different character
      encoding.  If you do this, you will definitely need to
      specialize ccl::select-stream-class.  Your method on
      ccl::stream-select-class should accept an instance of the class,
      but pay no attention to its contents, and return a symbol naming
      the class to actually be instantiated.</para>
      <para>If you need to make your functionality generic across all
      the different types of stream, probably the best way to
      implement it is to make it a mixin, define classes with all the
      variants of input, output, io, character, and binary, which
      inherit both from your mixin and from the appropriate other
      class, then define a method on ccl::select-stream-class which
      chooses from among those classes.</para>
      <para>Note that some of these classes are internal to the CLL
      package.  If you try to inherit from those ones without the
      ccl:: prefix, you'll get an error which may confuse you, calling
      them "forward-referenced classes".  That just means you used the
      wrong symbol, so add the prefix.</para>
      <para>Here's a list of some generic functions which you might
      wish to specialize for your new stream class, and which ought to
      be documented at some point.</para>
      <simplelist>
	<member>stream-direction stream =></member>
	<member>stream-device stream direction =></member>
	<member>stream-length stream &optional; new =></member>
	<member>stream-position stream &optional; new =></member>
	<member>streamp stream => boolean</member>
	<member>stream-write-char output-stream char =></member>
	<member>stream-write-entire-string output-stream string =></member>
	<member>stream-read-char input-stream =></member>
	<member>stream-unread-char input-stream char =></member>
	<member>stream-force-output output-stream => nil</member>
	<member>stream-maybe-force-output output-stream => nil</member>
	<member>stream-finish-output output-stream => nil</member>
	<member>stream-clear-output output-stream => nil</member>
	<member>close stream &key; abort => boolean</member>
	<member>stream-fresh-line stream => t</member>
	<member>stream-line-length stream => length</member>
	<member>interactive-stream-p stream => boolean</member>
	<member>stream-clear-input input-stream => nil</member>
	<member>stream-listen input-stream => boolean</member>
	<member>stream-filename stream => string</member>
	<member>ccl::select-stream-class instance in-p out-p char-p =>
	        class</member>
      </simplelist>
      <para>The following functions are standard parts of Common Lisp, but
behave in special ways with regard to Gray streams.</para>
      <simplelist>
	<member>open-stream-p stream => generalized-boolean</member>
	<member>input-stream-p stream => generalized-boolean</member>
	<member>output-stream-p stream => generalized-boolean</member>
	<member>stream-element-type stream =></member>
	<member>stream-error-stream =></member>
	<member>open</member>
	<member>close</member>
	<member>with-open-file</member>
      </simplelist>

      <para>Specifically, (open) and (with-open-file) accept a new
      keyword argument, :class, which may be a symbol naming a class;
      the class itself; or an instance of it.  The class so given must
      be a subtype of 'stream, and an instance of it with no
      particular contents will be passed to ccl::select-stream-class
      to determine what class to actually instantiate.</para>
      <para>The following are standard, and do not behave specially
      with regard to Gray streams, but probably should.</para>
       <simplelist>
	<member>stream-external-format</member>
      </simplelist>
    </sect1>

    <sect1 id="Extending-READ-SEQUENCE-and-WRITE-SEQUENCE">
      <title>Extending READ-SEQUENCE and WRITE-SEQUENCE</title>

      <sect2 id="extending-read-write-overview">
        <title>Overview</title>
	<para>The "Gray Streams" API is based on an informal proposal that was
	made before ANSI CL adopted the READ-SEQUENCE and WRITE-SEQUENCE
	functions; as such, there is no "standard" way for the author of a Gray
	stream class to improve the performance of these functions by exploiting
	knowledge of the stream's internals (e.g., the buffering mechanism it
	uses.)</para>
        <para>In the absence of any such knowledge, READ-SEQUENCE and
        WRITE-SEQUENCE are effectively just convenient shorthand for a
        loop which calls READ-CHAR/READ-BYTE/WRITE-CHAR/WRITE-BYTE as
        appropriate. The mechanism described below allows subclasses
        of FUNDAMENTAL-STREAM to define more specialized (and
        presumably more efficient) behavior.</para>
      </sect2>

      <sect2 id="Notes">
	<title>Notes</title>
        <para>READ-SEQUENCE and WRITE-SEQUENCE do a certain amount of
        sanity-checking and normalization of their arguments before
        dispatching to one of the methods above. If an individual
        method can't do anything particularly clever, CALL-NEXT-METHOD
        can be used to handle the general case.</para>
      </sect2>

      <sect2 id="Example">
        <title>Example</title>
        <programlisting>
(defclass my-string-input-stream (fundamental-character-input-stream)
  ((string :initarg :string :accessor my-string-input-stream-string)
   (index :initform 0 :accessor my-string-input-stream-index)
   (length)))

(defmethod stream-read-vector ((stream my-string-input-stream) vector start end)
  (if (not (typep vector 'simple-base-string))
      (call-next-method)
      (with-slots (string index length)
        (do* ((outpos start (1+ outpos)))
             ((or (= outpos end)
                  (= index length))
              outpos))
          (setf (schar vector outpos)
                (schar string index))
          (incf index)))))
</programlisting>
      </sect2>
    </sect1>

    <sect1 id="Multibyte-I-O">
      <title>Multibyte I/O</title>
      <para>All heap-allocated objects in OpenMCL that cannot contain
      pointers to lisp objects are represented as
      <emphasis>ivectors</emphasis>. OpenMCL provides low-level
      functions, and , to efficiently transfer data between buffered
      streams and ivectors. There's some overlap in functionality
      between the functions described here and the ANSI CL
      READ-SEQUENCE and WRITE-SEQUENCE functions.</para>
      <para>As used here, the term "octet" means roughly the same
      thing as the term "8-bit byte". The functions described below
      transfer a specified sequence of octets between a buffered
      stream and an ivector, and don't really concern themselves with
      higher-level issues (like whether that octet sequence is within
      bounds or how it relates to the logical contents of the
      ivector.) For these reasons, these functions are generally less
      safe and more flexible than their ANSI counterparts.</para>
    </sect1>

    <sect1 id="Gray-Streams-Dictionary">
      <title>Gray Streams Dictionary</title>
      <refentry id="f_stream-read-list">
	<indexterm zone="f_stream-read-list">
	  <primary>stream-read-list</primary>
	</indexterm>

	<refnamediv>
	  <refname>CCL:STREAM-READ-LIST</refname>
	  <refpurpose></refpurpose>
	  <refclass>Generic Function</refclass>
	</refnamediv>

	<refsynopsisdiv>
	  <synopsis><function>stream-read-list</function>
	  stream list count</synopsis>
	</refsynopsisdiv>

	<refsect1>
	  <title>Arguments and Values</title>

	  <variablelist>
	    <varlistentry>
	      <term>stream</term>

	      <listitem>
		<para>a stream, presumably a fundamental-input-stream.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>list</term>

	      <listitem>
		<para>a list. When a STREAM-READ-LIST method is called by
		READ-SEQUENCE, this argument is guaranteed to be a proper
		list.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>count</term>

	      <listitem>
		<para>a non-negative integer. When a STREAM-READ-LIST method
		is called by READ-SEQUENCE, this argument is guaranteed not
		to be greater than the length of the list.</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</refsect1>

	<refsect1>
	  <title>Description</title>

	  <para>Should try to read up to count elements from stream into the
	  list list, returning the number of elements actually read (which
	  may be less than count in case of a premature end-of-file.)</para>
	</refsect1>
      </refentry>

      <refentry id="f_stream-write-list">
	<indexterm zone="f_stream-write-list">
	  <primary>stream-write-list</primary>
	</indexterm>

	<refnamediv>
	  <refname>CCL:STREAM-WRITE-LIST</refname>
	  <refpurpose></refpurpose>
	  <refclass>Generic Function</refclass>
	</refnamediv>

	<refsynopsisdiv>
	  <synopsis><function>stream-write-list</function>
	  stream list count</synopsis>
	</refsynopsisdiv>

	<refsect1>
	  <title>Arguments and Values</title>

	  <variablelist>
	    <varlistentry>
	      <term>stream</term>

	      <listitem>
		<para>a stream, presumably a fundamental-ouput-stream.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>list</term>

	      <listitem>
		<para>a list. When a STREAM-WRITE-LIST method is called by
		WRITE-SEQUENCE, this argument is guaranteed to be a proper
		list.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>count</term>

	      <listitem>
		<para>a non-negative integer. When a STREAM-WRITE-LIST
		method is called by WRITE-SEQUENCE, this argument is
		guaranteed not to be greater than the length of the list.</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</refsect1>

	<refsect1>
	  <title>Description</title>

	  <para>should try to write the first count elements of list to
	  stream. The return value of this method is ignored.</para>
	</refsect1>
      </refentry>

      <refentry id="f_stream-read-vector">
	<indexterm zone="f_stream-read-vector">
	  <primary>stream-read-vector</primary>
	</indexterm>

	<refnamediv>
	  <refname>CCL:STREAM-READ-VECTOR</refname>
	  <refpurpose></refpurpose>
	  <refclass>Generic Function</refclass>
	</refnamediv>

	<refsynopsisdiv>
	  <synopsis><function>stream-read-vector</function>
	  stream vector start end</synopsis>
	</refsynopsisdiv>

	<refsect1>
	  <title>Arguments and Values</title>

	  <variablelist>
	    <varlistentry>
	      <term>stream</term>

	      <listitem>
		<para>a stream, presumably a fundamental-input-stream</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>vector</term>

	      <listitem>
		<para>a vector. When a STREAM-READ-VECTOR method is called
		by READ-SEQUENCE, this argument is guaranteed to be a simple
		one-dimensional array.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>start</term>

	      <listitem>
		<para>a non-negative integer. When a STREAM-READ-VECTOR
		method is called by READ-SEQUENCE, this argument is
		guaranteed to be no greater than end and not greater than
		the length of vector.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>end</term>

	      <listitem>
		<para>a non-negative integer. When a STREAM-READ-VECTOR
		method is called by READ-SEQUENCE, this argument is
		guaranteed to be no less than end and not greater than the
		length of vector.</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</refsect1>

	<refsect1>
	  <title>Description</title>

	  <para>should try to read successive elements from stream into
	  vector, starting at element start (inclusive) and continuing
	  through element end (exclusive.) Should return the index of the
	  vector element beyond the last one stored into, which may be less
	  than end in case of premature end-of-file.</para>
	</refsect1>
      </refentry>

      <refentry id="f_stream-write-vector">
	<indexterm zone="f_stream-write-vector">
	  <primary>stream-write-vector</primary>
	</indexterm>

	<refnamediv>
	  <refname>CCL:STREAM-WRITE-VECTOR</refname>
	  <refpurpose></refpurpose>
	  <refclass>Generic Function</refclass>
	</refnamediv>

	<refsynopsisdiv>
	  <synopsis><function>stream-write-vector</function>
	  stream vector start end</synopsis>
	</refsynopsisdiv>

	<refsect1>
	  <title>Arguments and Values</title>

	  <variablelist>
	    <varlistentry>
	      <term>stream</term>

	      <listitem>
		<para>a stream, presumably a fundamental-output-stream</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>vector</term>

	      <listitem>
		<para>a vector. When a STREAM-WRITE-VECTOR method is called
		by WRITE-SEQUENCE, this argument is guaranteed to be a
		simple one-dimensional array.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>start</term>

	      <listitem>
		<para>a non-negative integer. When a STREAM-WRITE-VECTOR
		method is called by WRITE-SEQUENCE, this argument is
		guaranteed to be no greater than end and not greater than
		the length of vector.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>end</term>

	      <listitem>
		<para>a non-negative integer. When a STREAM-WRITE-VECTOR
		method is called by WRITE-SEQUENCE, this argument is
		guaranteed to be no less than end and not greater than the
		length of vector.</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</refsect1>

	<refsect1>
	  <title>Description</title>

	  <para>should try to write successive elements of vector to stream,
	  starting at element start (inclusive) and continuing through
	  element end (exclusive.)</para>
	</refsect1>
      </refentry>

      <refentry id="f_stream-device">
	<indexterm zone="f_stream-device">
	  <primary>stream-device</primary>
	</indexterm>

	<refnamediv>
	  <refname>CCL::STREAM-DEVICE</refname>
	  <refpurpose>Returns the OS file descriptor associated with a
	  given lisp stream.</refpurpose>
	  <refclass>Generic Function</refclass>
	</refnamediv>

	<refsynopsisdiv>
	  <synopsis><function>ccl::stream-device</function>
	  s direction</synopsis>
	</refsynopsisdiv>

	<refsect1>
	  <title>Method Signatures</title>

	  <synopsis><function>ccl::stream-device</function>
	  (s stream) direction => fd</synopsis>
	</refsect1>

	<refsect1>
	  <title>Arguments and Values</title>
	  
	  <variablelist>
	    <varlistentry>
	      <term>s</term>
	      <listitem>
		<para>a stream.</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>direction</term>
	      <listitem>
		<para>either :INPUT or :OUTPUT.</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>fd</term>
	      <listitem>
		<para>a file descriptor, which is a non-negative integer
		used by the OS to refer to an open file, socket, or similar
		I/O connection.  NIL if there is no file descriptor associated
		with <varname>s</varname> in the direction given by
		<varname>direction</varname>.</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</refsect1>

	<refsect1>
	  <title>Description</title>

	  <para>Returns the file descriptor associated with
	  <varname>s</varname> in the direction given by
	  <varname>direction</varname>.  It is necessary to specify
	  <varname>direction</varname> because the input and output
	  file descriptors may be different; the most common case is when
	  one of them has been redirected by the Unix shell.</para>
	</refsect1>
      </refentry>

      <refentry id="f_stream-read-ivector">
	<indexterm zone="f_stream-read-ivector">
	  <primary>stream-read-ivector</primary>
	</indexterm>

	<refnamediv>
	  <refname>STREAM-READ-IVECTOR</refname>
	  <refpurpose></refpurpose>
	  <refclass>Generic Function</refclass>
	</refnamediv>

	<refsynopsisdiv>
	  <synopsis><function>stream-read-ivector</function>
	  stream ivector start-octet max-octets</synopsis>
	</refsynopsisdiv>

	<refsect1>
	  <title>Description</title>

	  <para>Reads up to max-octets octets from stream into ivector,
	  storing them at start-octet. Returns the number of octets actually
	  read.</para>
	</refsect1>

	<refsect1>
	  <title>Arguments</title>

	  <variablelist>
	    <varlistentry>
	      <term>stream</term>

	      <listitem>
		<para>An input stream. The method defined on
		BUFFERED-INPUT-STREAMs requires that the size in octets of
		an instance of the stream's element type is 1.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>ivector</term>

	      <listitem>
		<para>Any ivector.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>start-octet</term>

	      <listitem>
		<para>A non-negative integer.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>max-octets</term>

	      <listitem>
		<para>A non-negative integer. The return value may be less
		than the value of this parameter if EOF was encountered.</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</refsect1>
      </refentry>

      <refentry id="f_stream-write-ivector">
	<indexterm zone="f_stream-write-ivector">
	  <primary>stream-write-ivector</primary>
	</indexterm>

	<refnamediv>
	  <refname>STREAM-WRITE-IVECTOR</refname>
	  <refpurpose></refpurpose>
	  <refclass>Generic Function</refclass>
	</refnamediv>

	<refsynopsisdiv>
	  <synopsis><function>stream-write-ivector stream</function>
	  ivector start-octet max-octets</synopsis>
	</refsynopsisdiv>

	<refsect1>
	  <title>Description</title>

	  <para>Writes max-octets octets to stream from ivector, starting at
	  start-octet. Returns max-octets.</para>
	</refsect1>

	<refsect1>
	  <title>Arguments</title>

	  <variablelist>
	    <varlistentry>
	      <term>stream</term>

	      <listitem>
		<para>An input stream. The method defined on
		BUFFERED-OUTPUT-STREAMs requires that the size in octets of
		an instance of the stream's element type is 1.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>ivector</term>

	      <listitem>
		<para>Any ivector</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>start-octet</term>

	      <listitem>
		<para>A non-negative integer.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term>max-octet</term>

	      <listitem>
		<para>A non-negative integer.</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</refsect1>

	<refsect1>
	  <title>Examples</title>

<programlisting format="linespecific">;;; Write the contents of a (SIMPLE-ARRAY(UNSIGNED-BYTE 16) 3) 
;;; to a character file stream. Read back the characters.
(let* ((a (make-array 3 
                     :element-type '(unsigned-byte 16)
                     :initial-contents '(26725 27756 28449))))
  (with-open-file (s "junk"
                   :element-type 'character
                   :direction :io
                   :if-does-not-exist :create
                   :if-exists :supersede)
    ;; Write six octets (three elements).
    (stream-write-ivector s a 0 6)
    ;; Rewind, then read a line
    (file-position s 0)
    (read-line s)))

;;; Write a vector of DOUBLE-FLOATs. Note that (to maintain
;;; alignment) there are 4 octets of padding before the 0th 
;;; element of a (VECTOR DOUBLE-FLOAT).
;;; (Note that (= (- arch::misc-dfloat-offset 
;;;                  arch::misc-data-offset) 4))
(defun write-double-float-vector
  (stream vector &#38;key (start 0) (end (length vector)))
  (check-type vector (vector double-float))
  (let* ((start-octet (+ (* start 8) 
                         (- arch::misc-dfloat-offset
                         arch::misc-data-offset)))
         (num-octets (* 8 (- end start))))
    (stream-write-ivector stream vector start-octet num-octets)))</programlisting>
	</refsect1>
      </refentry>
    </sect1>
  </chapter>
